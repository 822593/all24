"""
pybind11 wrapper of hybrid
"""
from __future__ import annotations
import numpy
import typing
from . import gtsfm
from . import imuBias
from . import lago
from . import noiseModel
from . import symbol_shorthand
from . import utilities
__all__ = ['AHRSFactor', 'AcceleratingScenario', 'BarometricFactor', 'BatchFixedLagSmoother', 'BearingFactor2D', 'BearingFactor3D', 'BearingFactorPose2', 'BearingRange2D', 'BearingRange3D', 'BearingRangeFactor2D', 'BearingRangeFactor3D', 'BearingRangeFactorPose2', 'BearingRangeFactorPose3', 'BearingRangePose2', 'BearingRangePose3', 'BetweenFactorConstantBias', 'BetweenFactorDouble', 'BetweenFactorPoint2', 'BetweenFactorPoint3', 'BetweenFactorPose2', 'BetweenFactorPose3', 'BetweenFactorRot2', 'BetweenFactorRot3', 'BetweenFactorSO3', 'BetweenFactorSO4', 'BetweenFactorSimilarity3', 'BetweenFactorVector', 'BinaryMeasurementPoint3', 'BinaryMeasurementRot3', 'BinaryMeasurementUnit3', 'BlockJacobiPreconditionerParameters', 'Cal3Bundler', 'Cal3DS2', 'Cal3DS2_Base', 'Cal3Fisheye', 'Cal3Unified', 'Cal3_S2', 'Cal3_S2Stereo', 'CalibratedCamera', 'CameraSetCal3Bundler', 'CameraSetCal3DS2', 'CameraSetCal3Fisheye', 'CameraSetCal3Unified', 'CameraSetCal3_S2', 'Chebyshev1Basis', 'Chebyshev2', 'Chebyshev2Basis', 'CombinedImuFactor', 'ComponentDerivativeFactorChebyshev1Basis', 'ComponentDerivativeFactorChebyshev2', 'ComponentDerivativeFactorChebyshev2Basis', 'ComponentDerivativeFactorFourierBasis', 'ConjugateGradientParameters', 'ConstantTwistScenario', 'ConvertNoiseModel', 'CustomFactor', 'DSFMapIndexPair', 'DecisionTreeFactor', 'DegeneracyMode', 'DerivativeFactorChebyshev1Basis', 'DerivativeFactorChebyshev2', 'DerivativeFactorChebyshev2Basis', 'DerivativeFactorFourierBasis', 'DiscreteBayesNet', 'DiscreteBayesTree', 'DiscreteBayesTreeClique', 'DiscreteCluster', 'DiscreteConditional', 'DiscreteDistribution', 'DiscreteEliminationTree', 'DiscreteFactor', 'DiscreteFactorGraph', 'DiscreteJunctionTree', 'DiscreteKeys', 'DiscreteLookupDAG', 'DiscreteLookupTable', 'DiscreteValues', 'DoglegOptimizer', 'DoglegParams', 'DotWriter', 'DummyPreconditionerParameters', 'EliminateDiscrete', 'EliminateForMPE', 'EssentialMatrix', 'EssentialMatrixConstraint', 'EssentialMatrixFactor', 'EvaluationFactorChebyshev1Basis', 'EvaluationFactorChebyshev2', 'EvaluationFactorChebyshev2Basis', 'EvaluationFactorFourierBasis', 'Factor', 'FindKarcherMean', 'FitBasisChebyshev1Basis', 'FitBasisChebyshev2', 'FitBasisChebyshev2Basis', 'FitBasisFourierBasis', 'FixedLagSmoother', 'FixedLagSmootherResult', 'FourierBasis', 'FrobeniusBetweenFactorSO3', 'FrobeniusBetweenFactorSO4', 'FrobeniusFactorSO3', 'FrobeniusFactorSO4', 'GPSFactor', 'GPSFactor2', 'GaussNewtonOptimizer', 'GaussNewtonParams', 'GaussianBayesNet', 'GaussianBayesTree', 'GaussianConditional', 'GaussianDensity', 'GaussianFactor', 'GaussianFactorGraph', 'GaussianISAM', 'GaussianMixture', 'GaussianMixtureFactor', 'GeneralSFMFactor2Cal3Bundler', 'GeneralSFMFactor2Cal3DS2', 'GeneralSFMFactor2Cal3Fisheye', 'GeneralSFMFactor2Cal3Unified', 'GeneralSFMFactor2Cal3_S2', 'GeneralSFMFactorCal3Bundler', 'GeneralSFMFactorCal3DS2', 'GeneralSFMFactorCal3Fisheye', 'GeneralSFMFactorCal3Unified', 'GeneralSFMFactorCal3_S2', 'GeneralSFMFactorPoseCal3Bundler', 'GeneralSFMFactorPoseCal3DS2', 'GeneralSFMFactorPoseCal3Fisheye', 'GeneralSFMFactorPoseCal3Unified', 'GeneralSFMFactorPoseCal3_S2', 'GenericProjectionFactorCal3DS2', 'GenericProjectionFactorCal3Fisheye', 'GenericProjectionFactorCal3Unified', 'GenericProjectionFactorCal3_S2', 'GenericStereoFactor3D', 'GenericValueCal3Bundler', 'GenericValueCal3DS2', 'GenericValueCal3Fisheye', 'GenericValueCal3Unified', 'GenericValueCal3_S2', 'GenericValueCalibratedCamera', 'GenericValueConstantBias', 'GenericValueEssentialMatrix', 'GenericValueMatrix', 'GenericValuePoint2', 'GenericValuePoint3', 'GenericValuePose2', 'GenericValuePose3', 'GenericValueRot2', 'GenericValueRot3', 'GenericValueStereoPoint2', 'GenericValueVector', 'GncGaussNewtonOptimizer', 'GncGaussNewtonParams', 'GncLMOptimizer', 'GncLMParams', 'GncLossType', 'GraphvizFormatting', 'HessianFactor', 'HybridBayesNet', 'HybridBayesTree', 'HybridBayesTreeClique', 'HybridConditional', 'HybridFactor', 'HybridGaussianFactorGraph', 'HybridNonlinearFactorGraph', 'HybridValues', 'ISAM2', 'ISAM2Clique', 'ISAM2DoglegParams', 'ISAM2GaussNewtonParams', 'ISAM2Params', 'ISAM2Result', 'ISAM2ThresholdMap', 'ImuFactor', 'IndexPair', 'IndexPairSetAsArray', 'InitializePose3', 'IterativeOptimizationParameters', 'JacobianFactor', 'JacobianVector', 'JointMarginal', 'KalmanFilter', 'KarcherMeanFactorPoint2', 'KarcherMeanFactorPoint3', 'KarcherMeanFactorPose2', 'KarcherMeanFactorPose3', 'KarcherMeanFactorRot2', 'KarcherMeanFactorRot3', 'KarcherMeanFactorSO3', 'KarcherMeanFactorSO4', 'KernelFunctionType', 'KeyGroupMap', 'KeyList', 'KeySet', 'LabeledSymbol', 'LevenbergMarquardtOptimizer', 'LevenbergMarquardtParams', 'LinearContainerFactor', 'LinearizationMode', 'MFAS', 'ManifoldEvaluationFactorChebyshev1BasisPose2', 'ManifoldEvaluationFactorChebyshev1BasisPose3', 'ManifoldEvaluationFactorChebyshev1BasisRot2', 'ManifoldEvaluationFactorChebyshev1BasisRot3', 'ManifoldEvaluationFactorChebyshev2BasisPose2', 'ManifoldEvaluationFactorChebyshev2BasisPose3', 'ManifoldEvaluationFactorChebyshev2BasisRot2', 'ManifoldEvaluationFactorChebyshev2BasisRot3', 'ManifoldEvaluationFactorChebyshev2Pose2', 'ManifoldEvaluationFactorChebyshev2Pose3', 'ManifoldEvaluationFactorChebyshev2Rot2', 'ManifoldEvaluationFactorChebyshev2Rot3', 'ManifoldEvaluationFactorFourierBasisPose2', 'ManifoldEvaluationFactorFourierBasisPose3', 'ManifoldEvaluationFactorFourierBasisRot2', 'ManifoldEvaluationFactorFourierBasisRot3', 'Marginals', 'MixtureFactor', 'NavState', 'NoiseFormat', 'NoiseModelFactor', 'NonlinearEquality2Cal3_S2', 'NonlinearEquality2CalibratedCamera', 'NonlinearEquality2ConstantBias', 'NonlinearEquality2PinholeCameraCal3Bundler', 'NonlinearEquality2PinholeCameraCal3Fisheye', 'NonlinearEquality2PinholeCameraCal3Unified', 'NonlinearEquality2PinholeCameraCal3_S2', 'NonlinearEquality2Point2', 'NonlinearEquality2Point3', 'NonlinearEquality2Pose2', 'NonlinearEquality2Pose3', 'NonlinearEquality2Rot2', 'NonlinearEquality2Rot3', 'NonlinearEquality2SO3', 'NonlinearEquality2SO4', 'NonlinearEquality2SOn', 'NonlinearEquality2StereoPoint2', 'NonlinearEqualityCal3_S2', 'NonlinearEqualityCalibratedCamera', 'NonlinearEqualityConstantBias', 'NonlinearEqualityPinholeCameraCal3Bundler', 'NonlinearEqualityPinholeCameraCal3Fisheye', 'NonlinearEqualityPinholeCameraCal3Unified', 'NonlinearEqualityPinholeCameraCal3_S2', 'NonlinearEqualityPoint2', 'NonlinearEqualityPoint3', 'NonlinearEqualityPose2', 'NonlinearEqualityPose3', 'NonlinearEqualityRot2', 'NonlinearEqualityRot3', 'NonlinearEqualitySO3', 'NonlinearEqualitySO4', 'NonlinearEqualitySOn', 'NonlinearEqualityStereoPoint2', 'NonlinearFactor', 'NonlinearFactorGraph', 'NonlinearISAM', 'NonlinearOptimizer', 'NonlinearOptimizerParams', 'Ordering', 'PCGSolverParameters', 'PinholeCameraCal3Bundler', 'PinholeCameraCal3DS2', 'PinholeCameraCal3Fisheye', 'PinholeCameraCal3Unified', 'PinholeCameraCal3_S2', 'PinholePoseCal3Bundler', 'PinholePoseCal3DS2', 'PinholePoseCal3Fisheye', 'PinholePoseCal3Unified', 'PinholePoseCal3_S2', 'Pose2', 'Pose3', 'Pose3AttitudeFactor', 'PoseRotationPrior2D', 'PoseRotationPrior3D', 'PoseTranslationPrior2D', 'PoseTranslationPrior3D', 'PreconditionerParameters', 'PreintegratedAhrsMeasurements', 'PreintegratedCombinedMeasurements', 'PreintegratedImuMeasurements', 'PreintegratedRotationParams', 'PreintegrationCombinedParams', 'PreintegrationParams', 'PrintKeyList', 'PrintKeySet', 'PrintKeyVector', 'PriorFactorCal3Bundler', 'PriorFactorCal3DS2', 'PriorFactorCal3Fisheye', 'PriorFactorCal3Unified', 'PriorFactorCal3_S2', 'PriorFactorCalibratedCamera', 'PriorFactorConstantBias', 'PriorFactorDouble', 'PriorFactorPinholeCameraCal3Bundler', 'PriorFactorPinholeCameraCal3Fisheye', 'PriorFactorPinholeCameraCal3Unified', 'PriorFactorPinholeCameraCal3_S2', 'PriorFactorPoint2', 'PriorFactorPoint3', 'PriorFactorPose2', 'PriorFactorPose3', 'PriorFactorRot2', 'PriorFactorRot3', 'PriorFactorSO3', 'PriorFactorSO4', 'PriorFactorSOn', 'PriorFactorStereoPoint2', 'PriorFactorUnit3', 'PriorFactorVector', 'Quaternion', 'RangeFactor2', 'RangeFactor2D', 'RangeFactor3', 'RangeFactor3D', 'RangeFactorCalibratedCamera', 'RangeFactorCalibratedCameraPoint', 'RangeFactorPose2', 'RangeFactorPose3', 'RangeFactorSimpleCamera', 'RangeFactorSimpleCameraPoint', 'RangeFactorWithTransform2D', 'RangeFactorWithTransform3D', 'RangeFactorWithTransformBias2D', 'RangeFactorWithTransformBias3D', 'RangeFactorWithTransformPose2', 'RangeFactorWithTransformPose3', 'RedirectCout', 'Rot2', 'Rot3', 'Rot3AttitudeFactor', 'SO3', 'SO4', 'SOn', 'Sampler', 'Scenario', 'ScenarioRunner', 'SfmData', 'SfmTrack', 'SfmTrack2d', 'ShonanAveraging2', 'ShonanAveraging3', 'ShonanAveragingParameters2', 'ShonanAveragingParameters3', 'ShonanFactor3', 'Similarity2', 'Similarity3', 'SmartProjectionParams', 'SmartProjectionPose3Factor', 'StereoCamera', 'StereoPoint2', 'SubgraphSolver', 'SubgraphSolverParameters', 'Symbol', 'SymbolicBayesNet', 'SymbolicBayesTree', 'SymbolicBayesTreeClique', 'SymbolicCluster', 'SymbolicConditional', 'SymbolicEliminationTree', 'SymbolicFactor', 'SymbolicFactorGraph', 'SymbolicJunctionTree', 'TranslationRecovery', 'TriangulationParameters', 'TriangulationResult', 'Unit3', 'Value', 'Values', 'VariableIndex', 'VectorComponentFactorChebyshev1Basis', 'VectorComponentFactorChebyshev2', 'VectorComponentFactorChebyshev2Basis', 'VectorComponentFactorFourierBasis', 'VectorDerivativeFactorChebyshev1Basis', 'VectorDerivativeFactorChebyshev2', 'VectorDerivativeFactorChebyshev2Basis', 'VectorDerivativeFactorFourierBasis', 'VectorEvaluationFactorChebyshev1Basis', 'VectorEvaluationFactorChebyshev2', 'VectorEvaluationFactorChebyshev2Basis', 'VectorEvaluationFactorFourierBasis', 'VectorValues', 'cartesianProduct', 'checkConvergence', 'gtsfm', 'html', 'imuBias', 'initialCamerasAndPointsEstimate', 'initialCamerasEstimate', 'isDebugVersion', 'lago', 'linear_independent', 'load2D', 'load3D', 'markdown', 'mrsymbol', 'mrsymbolChr', 'mrsymbolIndex', 'mrsymbolLabel', 'noiseModel', 'parse2DFactors', 'parse3DFactors', 'readBal', 'readG2o', 'save2D', 'symbol', 'symbolChr', 'symbolIndex', 'symbol_shorthand', 'triangulateNonlinear', 'triangulatePoint3', 'triangulateSafe', 'utilities', 'writeBAL', 'writeG2o']
class AHRSFactor(NonlinearFactor):
    @typing.overload
    def __init__(self, rot_i: int, rot_j: int, bias: int, preintegratedMeasurements: PreintegratedAhrsMeasurements, omegaCoriolis: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, rot_i: int, rot_j: int, bias: int, preintegratedMeasurements: PreintegratedAhrsMeasurements, omegaCoriolis: numpy.ndarray[numpy.float64[m, 1]], body_P_sensor: Pose3) -> None:
        ...
    def evaluateError(self, rot_i: Rot3, rot_j: Rot3, bias: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def predict(self, rot_i: Rot3, bias: numpy.ndarray[numpy.float64[m, 1]], preintegratedMeasurements: PreintegratedAhrsMeasurements, omegaCoriolis: numpy.ndarray[numpy.float64[m, 1]]) -> Rot3:
        ...
    def preintegratedMeasurements(self) -> PreintegratedAhrsMeasurements:
        ...
class AcceleratingScenario(Scenario):
    def __init__(self, nRb: Rot3, p0: numpy.ndarray[numpy.float64[3, 1]], v0: numpy.ndarray[numpy.float64[m, 1]], a_n: numpy.ndarray[numpy.float64[m, 1]], omega_b: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class BarometricFactor(NonlinearFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, baroKey: int, baroIn: float, model: noiseModel.Base) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def baroOut(self, meters: float) -> float:
        ...
    def equals(self, expected: NonlinearFactor, tol: float) -> bool:
        ...
    def heightOut(self, n: float) -> float:
        ...
    def measurementIn(self) -> float:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class BatchFixedLagSmoother(FixedLagSmoother):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, smootherLag: float) -> None:
        ...
    @typing.overload
    def __init__(self, smootherLag: float, params: LevenbergMarquardtParams) -> None:
        ...
    def __repr__(self, s: str = 'BatchFixedLagSmoother:\n') -> str:
        ...
    def calculateEstimateCal3DS2(self, key: int) -> Cal3DS2:
        ...
    def calculateEstimateCal3_S2(self, key: int) -> Cal3_S2:
        ...
    def calculateEstimateMatrix(self, key: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def calculateEstimatePoint2(self, key: int) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def calculateEstimatePoint3(self, key: int) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calculateEstimatePose2(self, key: int) -> Pose2:
        ...
    def calculateEstimatePose3(self, key: int) -> Pose3:
        ...
    def calculateEstimateRot2(self, key: int) -> Rot2:
        ...
    def calculateEstimateRot3(self, key: int) -> Rot3:
        ...
    def calculateEstimateVector(self, key: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def params(self) -> LevenbergMarquardtParams:
        ...
    def print(self, s: str = 'BatchFixedLagSmoother:\n') -> None:
        ...
class BearingFactor2D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: Rot2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> Rot2:
        ...
    def serialize(self) -> str:
        ...
class BearingFactor3D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: Unit3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> Unit3:
        ...
    def serialize(self) -> str:
        ...
class BearingFactorPose2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: Rot2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> Rot2:
        ...
    def serialize(self) -> str:
        ...
class BearingRange2D:
    @staticmethod
    def Measure(pose: Pose2, point: numpy.ndarray[numpy.float64[2, 1]]) -> BearingRange2D:
        ...
    @staticmethod
    def MeasureBearing(pose: Pose2, point: numpy.ndarray[numpy.float64[2, 1]]) -> Rot2:
        ...
    @staticmethod
    def MeasureRange(pose: Pose2, point: numpy.ndarray[numpy.float64[2, 1]]) -> float:
        ...
    def __init__(self, b: Rot2, r: float) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def bearing(self) -> Rot2:
        ...
    def print(self, s: str = '') -> None:
        ...
    def range(self) -> float:
        ...
class BearingRange3D:
    @staticmethod
    def Measure(pose: Pose3, point: numpy.ndarray[numpy.float64[3, 1]]) -> BearingRange3D:
        ...
    @staticmethod
    def MeasureBearing(pose: Pose3, point: numpy.ndarray[numpy.float64[3, 1]]) -> Unit3:
        ...
    @staticmethod
    def MeasureRange(pose: Pose3, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    def __init__(self, b: Unit3, r: float) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def bearing(self) -> Unit3:
        ...
    def print(self, s: str = '') -> None:
        ...
    def range(self) -> float:
        ...
class BearingRangeFactor2D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, poseKey: int, pointKey: int, measuredBearing: Rot2, measuredRange: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> BearingRange2D:
        ...
    def serialize(self) -> str:
        ...
class BearingRangeFactor3D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, poseKey: int, pointKey: int, measuredBearing: Unit3, measuredRange: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> BearingRange3D:
        ...
    def serialize(self) -> str:
        ...
class BearingRangeFactorPose2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, poseKey: int, pointKey: int, measuredBearing: Rot2, measuredRange: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> BearingRangePose2:
        ...
    def serialize(self) -> str:
        ...
class BearingRangeFactorPose3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, poseKey: int, pointKey: int, measuredBearing: Unit3, measuredRange: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> BearingRangePose3:
        ...
    def serialize(self) -> str:
        ...
class BearingRangePose2:
    @staticmethod
    def Measure(pose: Pose2, point: Pose2) -> BearingRangePose2:
        ...
    @staticmethod
    def MeasureBearing(pose: Pose2, point: Pose2) -> Rot2:
        ...
    @staticmethod
    def MeasureRange(pose: Pose2, point: Pose2) -> float:
        ...
    def __init__(self, b: Rot2, r: float) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def bearing(self) -> Rot2:
        ...
    def print(self, s: str = '') -> None:
        ...
    def range(self) -> float:
        ...
class BearingRangePose3:
    @staticmethod
    def Measure(pose: Pose3, point: Pose3) -> BearingRangePose3:
        ...
    @staticmethod
    def MeasureBearing(pose: Pose3, point: Pose3) -> Unit3:
        ...
    @staticmethod
    def MeasureRange(pose: Pose3, point: Pose3) -> float:
        ...
    def __init__(self, b: Unit3, r: float) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def bearing(self) -> Unit3:
        ...
    def print(self, s: str = '') -> None:
        ...
    def range(self) -> float:
        ...
class BetweenFactorConstantBias(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: ..., noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> ...:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorDouble(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorPoint2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorPoint3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: numpy.ndarray[numpy.float64[3, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorPose2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: Pose2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> Pose2:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorPose3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: Pose3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> Pose3:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorRot2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: Rot2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> Rot2:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorRot3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: Rot3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> Rot3:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorSO3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: SO3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> SO3:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorSO4(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: SO4, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> SO4:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorSimilarity3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: Similarity3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> Similarity3:
        ...
    def serialize(self) -> str:
        ...
class BetweenFactorVector(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, relativePose: numpy.ndarray[numpy.float64[m, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def serialize(self) -> str:
        ...
class BinaryMeasurementPoint3:
    def __init__(self, key1: int, key2: int, measured: numpy.ndarray[numpy.float64[3, 1]], model: noiseModel.Base) -> None:
        ...
    def key1(self) -> int:
        ...
    def key2(self) -> int:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def noiseModel(self) -> noiseModel.Base:
        ...
class BinaryMeasurementRot3:
    def __init__(self, key1: int, key2: int, measured: Rot3, model: noiseModel.Base) -> None:
        ...
    def key1(self) -> int:
        ...
    def key2(self) -> int:
        ...
    def measured(self) -> Rot3:
        ...
    def noiseModel(self) -> noiseModel.Base:
        ...
class BinaryMeasurementUnit3:
    def __init__(self, key1: int, key2: int, measured: Unit3, model: noiseModel.Base) -> None:
        ...
    def key1(self) -> int:
        ...
    def key2(self) -> int:
        ...
    def measured(self) -> Unit3:
        ...
    def noiseModel(self) -> noiseModel.Base:
        ...
class BlockJacobiPreconditionerParameters(PreconditionerParameters):
    def __init__(self) -> None:
        ...
class Cal3Bundler:
    @staticmethod
    def Dim() -> int:
        ...
    def K(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, fx: float, k1: float, k2: float, u0: float, v0: float) -> None:
        ...
    @typing.overload
    def __init__(self, fx: float, k1: float, k2: float, u0: float, v0: float, tol: float) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, rhs: Cal3Bundler, tol: float) -> bool:
        ...
    def fx(self) -> float:
        ...
    def fy(self) -> float:
        ...
    def k(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    def k1(self) -> float:
        ...
    def k2(self) -> float:
        ...
    def localCoordinates(self, c: Cal3Bundler) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def px(self) -> float:
        ...
    def py(self) -> float:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Cal3Bundler:
        ...
    def serialize(self) -> str:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def vector(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class Cal3DS2(Cal3DS2_Base):
    @staticmethod
    def Dim() -> int:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, k1: float, k2: float) -> None:
        ...
    @typing.overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, k1: float, k2: float, p1: float, p2: float) -> None:
        ...
    @typing.overload
    def __init__(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, rhs: Cal3DS2, tol: float) -> bool:
        ...
    def localCoordinates(self, c: Cal3DS2) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Cal3DS2:
        ...
    def serialize(self) -> str:
        ...
class Cal3DS2_Base:
    def K(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def fx(self) -> float:
        ...
    def fy(self) -> float:
        ...
    def k(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    def k1(self) -> float:
        ...
    def k2(self) -> float:
        ...
    def print(self, s: str = '') -> None:
        ...
    def px(self) -> float:
        ...
    def py(self) -> float:
        ...
    def serialize(self) -> str:
        ...
    def skew(self) -> float:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def vector(self) -> numpy.ndarray[numpy.float64[9, 1]]:
        ...
class Cal3Fisheye:
    @staticmethod
    def Dim() -> int:
        ...
    def K(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, k1: float, k2: float, k3: float, k4: float, tol: float = 1e-05) -> None:
        ...
    @typing.overload
    def __init__(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def __repr__(self, s: str = 'Cal3Fisheye') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, rhs: Cal3Fisheye, tol: float) -> bool:
        ...
    def fx(self) -> float:
        ...
    def fy(self) -> float:
        ...
    def inverse(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def k(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    def k1(self) -> float:
        ...
    def k2(self) -> float:
        ...
    def k3(self) -> float:
        ...
    def k4(self) -> float:
        ...
    def localCoordinates(self, c: Cal3Fisheye) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def principalPoint(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def print(self, s: str = 'Cal3Fisheye') -> None:
        ...
    def px(self) -> float:
        ...
    def py(self) -> float:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Cal3Fisheye:
        ...
    def serialize(self) -> str:
        ...
    def skew(self) -> float:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def vector(self) -> numpy.ndarray[numpy.float64[9, 1]]:
        ...
class Cal3Unified(Cal3DS2_Base):
    @staticmethod
    def Dim() -> int:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, k1: float, k2: float) -> None:
        ...
    @typing.overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, k1: float, k2: float, p1: float, p2: float, xi: float) -> None:
        ...
    @typing.overload
    def __init__(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, rhs: Cal3Unified, tol: float) -> bool:
        ...
    def localCoordinates(self, c: Cal3Unified) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def nPlaneToSpace(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Cal3Unified:
        ...
    def serialize(self) -> str:
        ...
    def spaceToNPlane(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def xi(self) -> float:
        ...
class Cal3_S2:
    @staticmethod
    def Dim() -> int:
        ...
    def K(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float) -> None:
        ...
    @typing.overload
    def __init__(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, fov: float, w: int, h: int) -> None:
        ...
    def __repr__(self, s: str = 'Cal3_S2') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def calibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, rhs: Cal3_S2, tol: float) -> bool:
        ...
    def fx(self) -> float:
        ...
    def fy(self) -> float:
        ...
    def inverse(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def localCoordinates(self, c: Cal3_S2) -> numpy.ndarray[numpy.float64[5, 1]]:
        ...
    def principalPoint(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def print(self, s: str = 'Cal3_S2') -> None:
        ...
    def px(self) -> float:
        ...
    def py(self) -> float:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Cal3_S2:
        ...
    def serialize(self) -> str:
        ...
    def skew(self) -> float:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def uncalibrate(self, p: numpy.ndarray[numpy.float64[2, 1]], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def vector(self) -> numpy.ndarray[numpy.float64[5, 1]]:
        ...
class Cal3_S2Stereo:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, fx: float, fy: float, s: float, u0: float, v0: float, b: float) -> None:
        ...
    @typing.overload
    def __init__(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def baseline(self) -> float:
        ...
    def equals(self, K: Cal3_S2Stereo, tol: float) -> bool:
        ...
    def fx(self) -> float:
        ...
    def fy(self) -> float:
        ...
    def principalPoint(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def px(self) -> float:
        ...
    def py(self) -> float:
        ...
    def skew(self) -> float:
        ...
class CalibratedCamera:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    def Level(pose2: Pose2, height: float) -> CalibratedCamera:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def __repr__(self, s: str = 'CalibratedCamera') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: CalibratedCamera, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: CalibratedCamera) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'CalibratedCamera') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, point: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, camera: CalibratedCamera) -> float:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> CalibratedCamera:
        ...
    def serialize(self) -> str:
        ...
class CameraSetCal3Bundler:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> CameraSetCal3Bundler:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> PinholeCameraCal3Bundler:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CameraSetCal3Bundler) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self: list[PinholeCameraCal3Bundler]) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: PinholeCameraCal3Bundler) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: CameraSetCal3Bundler) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: PinholeCameraCal3Bundler) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: CameraSetCal3Bundler) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: PinholeCameraCal3Bundler) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> PinholeCameraCal3Bundler:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> PinholeCameraCal3Bundler:
        """
        Remove and return the item at index ``i``
        """
class CameraSetCal3DS2:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> CameraSetCal3DS2:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> PinholeCameraCal3DS2:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CameraSetCal3DS2) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self: list[PinholeCameraCal3DS2]) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: PinholeCameraCal3DS2) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: CameraSetCal3DS2) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: PinholeCameraCal3DS2) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: CameraSetCal3DS2) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: PinholeCameraCal3DS2) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> PinholeCameraCal3DS2:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> PinholeCameraCal3DS2:
        """
        Remove and return the item at index ``i``
        """
class CameraSetCal3Fisheye:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> CameraSetCal3Fisheye:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> PinholeCameraCal3Fisheye:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CameraSetCal3Fisheye) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self: list[PinholeCameraCal3Fisheye]) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: PinholeCameraCal3Fisheye) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: CameraSetCal3Fisheye) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: PinholeCameraCal3Fisheye) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: CameraSetCal3Fisheye) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: PinholeCameraCal3Fisheye) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> PinholeCameraCal3Fisheye:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> PinholeCameraCal3Fisheye:
        """
        Remove and return the item at index ``i``
        """
class CameraSetCal3Unified:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> CameraSetCal3Unified:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> PinholeCameraCal3Unified:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CameraSetCal3Unified) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self: list[PinholeCameraCal3Unified]) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: PinholeCameraCal3Unified) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: CameraSetCal3Unified) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: PinholeCameraCal3Unified) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: CameraSetCal3Unified) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: PinholeCameraCal3Unified) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> PinholeCameraCal3Unified:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> PinholeCameraCal3Unified:
        """
        Remove and return the item at index ``i``
        """
class CameraSetCal3_S2:
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, s: slice) -> CameraSetCal3_S2:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> PinholeCameraCal3_S2:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: CameraSetCal3_S2) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self: list[PinholeCameraCal3_S2]) -> int:
        ...
    @typing.overload
    def __setitem__(self, arg0: int, arg1: PinholeCameraCal3_S2) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: CameraSetCal3_S2) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: PinholeCameraCal3_S2) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    @typing.overload
    def extend(self, L: CameraSetCal3_S2) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: PinholeCameraCal3_S2) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> PinholeCameraCal3_S2:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> PinholeCameraCal3_S2:
        """
        Remove and return the item at index ``i``
        """
class Chebyshev1Basis:
    @staticmethod
    def CalculateWeights(N: int, x: float) -> numpy.ndarray[numpy.float64[1, n]]:
        ...
    @staticmethod
    def WeightMatrix(N: int, X: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
class Chebyshev2:
    @staticmethod
    def CalculateWeights(N: int, x: float, a: float, b: float) -> numpy.ndarray[numpy.float64[1, n]]:
        ...
    @staticmethod
    def DerivativeWeights(N: int, x: float, a: float, b: float) -> numpy.ndarray[numpy.float64[1, n]]:
        ...
    @staticmethod
    def DifferentiationMatrix(N: int, a: float, b: float) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @staticmethod
    def IntegrationWeights(N: int, a: float, b: float) -> numpy.ndarray[numpy.float64[1, n]]:
        ...
    @staticmethod
    @typing.overload
    def Point(N: int, j: int) -> float:
        ...
    @staticmethod
    @typing.overload
    def Point(N: int, j: int, a: float, b: float) -> float:
        ...
    @staticmethod
    @typing.overload
    def Points(N: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @staticmethod
    @typing.overload
    def Points(N: int, a: float, b: float) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @staticmethod
    @typing.overload
    def WeightMatrix(N: int, X: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @staticmethod
    @typing.overload
    def WeightMatrix(N: int, X: numpy.ndarray[numpy.float64[m, 1]], a: float, b: float) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
class Chebyshev2Basis:
    @staticmethod
    def CalculateWeights(N: int, x: float) -> numpy.ndarray[numpy.float64[1, n]]:
        ...
    @staticmethod
    def WeightMatrix(N: int, x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
class CombinedImuFactor(NonlinearFactor):
    def __init__(self, pose_i: int, vel_i: int, pose_j: int, vel_j: int, bias_i: int, bias_j: int, CombinedPreintegratedMeasurements: PreintegratedCombinedMeasurements) -> None:
        ...
    def evaluateError(self, pose_i: Pose3, vel_i: numpy.ndarray[numpy.float64[m, 1]], pose_j: Pose3, vel_j: numpy.ndarray[numpy.float64[m, 1]], bias_i: imuBias.ConstantBias, bias_j: imuBias.ConstantBias) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def preintegratedMeasurements(self) -> PreintegratedCombinedMeasurements:
        ...
class ComponentDerivativeFactorChebyshev1Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, P: int, N: int, i: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, P: int, N: int, i: int, x: float, a: float, b: float) -> None:
        ...
class ComponentDerivativeFactorChebyshev2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, P: int, N: int, i: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, P: int, N: int, i: int, x: float, a: float, b: float) -> None:
        ...
class ComponentDerivativeFactorChebyshev2Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, P: int, N: int, i: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, P: int, N: int, i: int, x: float, a: float, b: float) -> None:
        ...
class ComponentDerivativeFactorFourierBasis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, P: int, N: int, i: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, P: int, N: int, i: int, x: float, a: float, b: float) -> None:
        ...
class ConjugateGradientParameters(IterativeOptimizationParameters):
    def __init__(self) -> None:
        ...
    def getEpsilon_abs(self) -> float:
        ...
    def getEpsilon_rel(self) -> float:
        ...
    def getMaxIterations(self) -> int:
        ...
    def getMinIterations(self) -> int:
        ...
    def getReset(self) -> int:
        ...
    def setEpsilon_abs(self, value: float) -> None:
        ...
    def setEpsilon_rel(self, value: float) -> None:
        ...
    def setMaxIterations(self, value: int) -> None:
        ...
    def setMinIterations(self, value: int) -> None:
        ...
    def setReset(self, value: int) -> None:
        ...
class ConstantTwistScenario(Scenario):
    @typing.overload
    def __init__(self, w: numpy.ndarray[numpy.float64[m, 1]], v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, w: numpy.ndarray[numpy.float64[m, 1]], v: numpy.ndarray[numpy.float64[m, 1]], nTb0: Pose3) -> None:
        ...
class CustomFactor(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, noiseModel: noiseModel.Base, keys: list[int], errorFunction: typing.Callable[[CustomFactor, Values, ..., -1, -1, 0, -1, ..., ..., -1, -1, 0, -1, ...], numpy.ndarray[numpy.float64[m, 1]]]) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class DSFMapIndexPair:
    def __init__(self) -> None:
        ...
    def find(self, key: IndexPair) -> IndexPair:
        ...
    def merge(self, x: IndexPair, y: IndexPair) -> None:
        ...
    def sets(self) -> dict[IndexPair, set[IndexPair]]:
        ...
class DecisionTreeFactor(DiscreteFactor):
    def __call__(self, arg0: ...) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: tuple[int, int], spec: list[float]) -> None:
        ...
    @typing.overload
    def __init__(self, key: tuple[int, int], table: str) -> None:
        ...
    @typing.overload
    def __init__(self, keys: DiscreteKeys, table: list[float]) -> None:
        ...
    @typing.overload
    def __init__(self, keys: DiscreteKeys, table: str) -> None:
        ...
    @typing.overload
    def __init__(self, keys: list[tuple[int, int]], table: list[float]) -> None:
        ...
    @typing.overload
    def __init__(self, keys: list[tuple[int, int]], table: str) -> None:
        ...
    @typing.overload
    def __init__(self, c: ...) -> None:
        ...
    def __mul__(self, arg0: DecisionTreeFactor) -> DecisionTreeFactor:
        ...
    def __repr__(self, s: str = 'DecisionTreeFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def __truediv__(self, arg0: DecisionTreeFactor) -> DecisionTreeFactor:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    @typing.overload
    def cardinality(self, j: int) -> int:
        ...
    @typing.overload
    def cardinality(self, j: int) -> int:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ..., showZero: bool = True) -> str:
        ...
    def enumerate(self) -> list[tuple[..., float]]:
        ...
    def equals(self, other: DecisionTreeFactor, tol: float = 1e-09) -> bool:
        ...
    @typing.overload
    def max(self, nrFrontals: int) -> DecisionTreeFactor:
        ...
    @typing.overload
    def max(self, keys: Ordering) -> DecisionTreeFactor:
        ...
    def print(self, s: str = 'DecisionTreeFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def sum(self, nrFrontals: int) -> DecisionTreeFactor:
        ...
    @typing.overload
    def sum(self, keys: Ordering) -> DecisionTreeFactor:
        ...
class DegeneracyMode:
    """
    Members:
    
      IGNORE_DEGENERACY
    
      ZERO_ON_DEGENERACY
    
      HANDLE_INFINITY
    """
    HANDLE_INFINITY: typing.ClassVar[DegeneracyMode]  # value = <DegeneracyMode.HANDLE_INFINITY: 2>
    IGNORE_DEGENERACY: typing.ClassVar[DegeneracyMode]  # value = <DegeneracyMode.IGNORE_DEGENERACY: 0>
    ZERO_ON_DEGENERACY: typing.ClassVar[DegeneracyMode]  # value = <DegeneracyMode.ZERO_ON_DEGENERACY: 1>
    __members__: typing.ClassVar[dict[str, DegeneracyMode]]  # value = {'IGNORE_DEGENERACY': <DegeneracyMode.IGNORE_DEGENERACY: 0>, 'ZERO_ON_DEGENERACY': <DegeneracyMode.ZERO_ON_DEGENERACY: 1>, 'HANDLE_INFINITY': <DegeneracyMode.HANDLE_INFINITY: 2>}
    def __and__(self, other: typing.Any) -> typing.Any:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __invert__(self) -> typing.Any:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __or__(self, other: typing.Any) -> typing.Any:
        ...
    def __rand__(self, other: typing.Any) -> typing.Any:
        ...
    def __repr__(self) -> str:
        ...
    def __ror__(self, other: typing.Any) -> typing.Any:
        ...
    def __rxor__(self, other: typing.Any) -> typing.Any:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __xor__(self, other: typing.Any) -> typing.Any:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class DerivativeFactorChebyshev1Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class DerivativeFactorChebyshev2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class DerivativeFactorChebyshev2Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class DerivativeFactorFourierBasis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class DiscreteBayesNet:
    def __call__(self, arg0: ...) -> float:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = 'DiscreteBayesNet\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    @typing.overload
    def add(self, s: DiscreteConditional) -> None:
        ...
    @typing.overload
    def add(self, key: tuple[int, int], spec: str) -> None:
        ...
    @typing.overload
    def add(self, key: tuple[int, int], parents: DiscreteKeys, spec: str) -> None:
        ...
    @typing.overload
    def add(self, key: tuple[int, int], parents: list[tuple[int, int]], spec: str) -> None:
        ...
    def at(self, i: int) -> DiscreteConditional:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, other: DiscreteBayesNet, tol: float = 1e-09) -> bool:
        ...
    def evaluate(self, values: ...) -> float:
        ...
    def keys(self) -> ...:
        ...
    def logProbability(self, values: ...) -> float:
        ...
    def print(self, s: str = 'DiscreteBayesNet\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def sample(self) -> ...:
        ...
    @typing.overload
    def sample(self, given: ...) -> ...:
        ...
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> None:
        ...
    def size(self) -> int:
        ...
class DiscreteBayesTree:
    @typing.overload
    def __call__(self, arg0: ...) -> float:
        ...
    @typing.overload
    def __call__(self, arg0: ...) -> float:
        ...
    def __getitem__(self, arg0: int) -> DiscreteBayesTreeClique:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = 'DiscreteBayesTree\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, other: DiscreteBayesTree, tol: float = 1e-09) -> bool:
        ...
    def evaluate(self, values: ...) -> float:
        ...
    def print(self, s: str = 'DiscreteBayesTree\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def size(self) -> int:
        ...
class DiscreteBayesTreeClique:
    def __call__(self, arg0: ...) -> float:
        ...
    def __getitem__(self, arg0: int) -> DiscreteBayesTreeClique:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, conditional: DiscreteConditional) -> None:
        ...
    def __repr__(self, s: str = 'DiscreteBayesTreeClique', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def conditional(self) -> DiscreteConditional:
        ...
    def evaluate(self, values: ...) -> float:
        ...
    def isRoot(self) -> bool:
        ...
    def nrChildren(self) -> int:
        ...
    def print(self, s: str = 'DiscreteBayesTreeClique', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def printSignature(self, s: str = 'Clique: ', formatter: typing.Callable[[int], str] = ...) -> None:
        ...
class DiscreteCluster:
    factors: DiscreteFactorGraph
    orderedFrontalKeys: Ordering
    def __getitem__(self, arg0: int) -> DiscreteCluster:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def nrChildren(self) -> int:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class DiscreteConditional(DecisionTreeFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, nFrontals: int, f: DecisionTreeFactor) -> None:
        ...
    @typing.overload
    def __init__(self, key: tuple[int, int], spec: str) -> None:
        ...
    @typing.overload
    def __init__(self, key: tuple[int, int], parents: DiscreteKeys, spec: str) -> None:
        ...
    @typing.overload
    def __init__(self, key: tuple[int, int], parents: list[tuple[int, int]], spec: str) -> None:
        ...
    @typing.overload
    def __init__(self, joint: DecisionTreeFactor, marginal: DecisionTreeFactor) -> None:
        ...
    @typing.overload
    def __init__(self, joint: DecisionTreeFactor, marginal: DecisionTreeFactor, orderedKeys: Ordering) -> None:
        ...
    def __mul__(self, arg0: DiscreteConditional) -> DiscreteConditional:
        ...
    def __repr__(self, s: str = 'Discrete Conditional\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    def choose(self, given: ...) -> DiscreteConditional:
        ...
    def equals(self, other: DiscreteConditional, tol: float = 1e-09) -> bool:
        ...
    @typing.overload
    def error(self, values: ...) -> float:
        ...
    @typing.overload
    def error(self, x: ...) -> float:
        ...
    @typing.overload
    def evaluate(self, values: ...) -> float:
        ...
    @typing.overload
    def evaluate(self, x: ...) -> float:
        ...
    def firstFrontalKey(self) -> int:
        ...
    @typing.overload
    def likelihood(self, frontalValues: ...) -> DecisionTreeFactor:
        ...
    @typing.overload
    def likelihood(self, value: int) -> DecisionTreeFactor:
        ...
    def logNormalizationConstant(self) -> float:
        ...
    @typing.overload
    def logProbability(self, values: ...) -> float:
        ...
    @typing.overload
    def logProbability(self, x: ...) -> float:
        ...
    def marginal(self, key: int) -> DiscreteConditional:
        ...
    def nrFrontals(self) -> int:
        ...
    def nrParents(self) -> int:
        ...
    def print(self, s: str = 'Discrete Conditional\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def printSignature(self, s: str = 'Discrete Conditional: ', formatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def sample(self, parentsValues: ...) -> int:
        ...
    @typing.overload
    def sample(self, value: int) -> int:
        ...
    @typing.overload
    def sample(self) -> int:
        ...
    def sampleInPlace(self, parentsValues: ...) -> None:
        ...
class DiscreteDistribution(DiscreteConditional):
    def __call__(self, arg0: int) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, f: DecisionTreeFactor) -> None:
        ...
    @typing.overload
    def __init__(self, key: tuple[int, int], spec: str) -> None:
        ...
    @typing.overload
    def __init__(self, key: tuple[int, int], spec: list[float]) -> None:
        ...
    def __repr__(self, s: str = 'Discrete Prior\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def argmax(self) -> int:
        ...
    def pmf(self) -> list[float]:
        ...
    def print(self, s: str = 'Discrete Prior\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class DiscreteEliminationTree:
    @typing.overload
    def __init__(self, factorGraph: DiscreteFactorGraph, structure: VariableIndex, order: Ordering) -> None:
        ...
    @typing.overload
    def __init__(self, factorGraph: DiscreteFactorGraph, order: Ordering) -> None:
        ...
    def __repr__(self, name: str = 'EliminationTree: ', formatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, other: DiscreteEliminationTree, tol: float = 1e-09) -> bool:
        ...
    def print(self, name: str = 'EliminationTree: ', formatter: typing.Callable[[int], str] = ...) -> None:
        ...
class DiscreteFactor(Factor):
    def __call__(self, arg0: ...) -> float:
        ...
    def __repr__(self, s: str = 'DiscreteFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, other: DiscreteFactor, tol: float = 1e-09) -> bool:
        ...
    def print(self, s: str = 'DiscreteFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class DiscreteFactorGraph:
    def __call__(self, arg0: ...) -> float:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, bayesNet: DiscreteBayesNet) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_html_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def _repr_markdown_(self, keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
        ...
    @typing.overload
    def add(self, j: tuple[int, int], spec: str) -> None:
        ...
    @typing.overload
    def add(self, j: tuple[int, int], spec: list[float]) -> None:
        ...
    @typing.overload
    def add(self, keys: DiscreteKeys, spec: str) -> None:
        ...
    @typing.overload
    def add(self, keys: list[tuple[int, int]], spec: str) -> None:
        ...
    @typing.overload
    def add(self, keys: list[tuple[int, int]], spec: list[float]) -> None:
        ...
    def at(self, i: int) -> DiscreteFactor:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> str:
        ...
    @typing.overload
    def eliminateMultifrontal(self, type: Ordering.OrderingType = Ordering.OrderingType.COLAMD) -> DiscreteBayesTree:
        ...
    @typing.overload
    def eliminateMultifrontal(self, type: Ordering.OrderingType, function: typing.Callable[[DiscreteFactorGraph, Ordering], tuple[DiscreteConditional, DiscreteFactor]]) -> DiscreteBayesTree:
        ...
    @typing.overload
    def eliminateMultifrontal(self, ordering: Ordering) -> DiscreteBayesTree:
        ...
    @typing.overload
    def eliminateMultifrontal(self, ordering: Ordering, function: typing.Callable[[DiscreteFactorGraph, Ordering], tuple[DiscreteConditional, DiscreteFactor]]) -> DiscreteBayesTree:
        ...
    @typing.overload
    def eliminatePartialMultifrontal(self, ordering: Ordering) -> tuple[DiscreteBayesTree, DiscreteFactorGraph]:
        ...
    @typing.overload
    def eliminatePartialMultifrontal(self, ordering: Ordering, function: typing.Callable[[DiscreteFactorGraph, Ordering], tuple[DiscreteConditional, DiscreteFactor]]) -> tuple[DiscreteBayesTree, DiscreteFactorGraph]:
        ...
    @typing.overload
    def eliminatePartialSequential(self, ordering: Ordering) -> tuple[DiscreteBayesNet, DiscreteFactorGraph]:
        ...
    @typing.overload
    def eliminatePartialSequential(self, ordering: Ordering, function: typing.Callable[[DiscreteFactorGraph, Ordering], tuple[DiscreteConditional, DiscreteFactor]]) -> tuple[DiscreteBayesNet, DiscreteFactorGraph]:
        ...
    @typing.overload
    def eliminateSequential(self, type: Ordering.OrderingType = Ordering.OrderingType.COLAMD) -> DiscreteBayesNet:
        ...
    @typing.overload
    def eliminateSequential(self, type: Ordering.OrderingType, function: typing.Callable[[DiscreteFactorGraph, Ordering], tuple[DiscreteConditional, DiscreteFactor]]) -> DiscreteBayesNet:
        ...
    @typing.overload
    def eliminateSequential(self, ordering: Ordering) -> DiscreteBayesNet:
        ...
    @typing.overload
    def eliminateSequential(self, ordering: Ordering, function: typing.Callable[[DiscreteFactorGraph, Ordering], tuple[DiscreteConditional, DiscreteFactor]]) -> DiscreteBayesNet:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, fg: DiscreteFactorGraph, tol: float = 1e-09) -> bool:
        ...
    def keys(self) -> ...:
        ...
    @typing.overload
    def maxProduct(self, type: Ordering.OrderingType = Ordering.OrderingType.COLAMD) -> DiscreteLookupDAG:
        ...
    @typing.overload
    def maxProduct(self, ordering: Ordering) -> DiscreteLookupDAG:
        ...
    def optimize(self) -> ...:
        ...
    def print(self, s: str = '') -> None:
        ...
    def product(self) -> DecisionTreeFactor:
        ...
    @typing.overload
    def push_back(self, factor: DiscreteFactor) -> None:
        ...
    @typing.overload
    def push_back(self, conditional: DiscreteConditional) -> None:
        ...
    @typing.overload
    def push_back(self, graph: DiscreteFactorGraph) -> None:
        ...
    @typing.overload
    def push_back(self, bayesNet: DiscreteBayesNet) -> None:
        ...
    @typing.overload
    def push_back(self, bayesTree: DiscreteBayesTree) -> None:
        ...
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> None:
        ...
    def size(self) -> int:
        ...
    @typing.overload
    def sumProduct(self, type: Ordering.OrderingType = Ordering.OrderingType.COLAMD) -> DiscreteBayesNet:
        ...
    @typing.overload
    def sumProduct(self, ordering: Ordering) -> DiscreteBayesNet:
        ...
class DiscreteJunctionTree:
    def __getitem__(self, arg0: int) -> DiscreteCluster:
        ...
    def __init__(self, eliminationTree: DiscreteEliminationTree) -> None:
        ...
    def __repr__(self, name: str = 'JunctionTree: ', formatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def nrRoots(self) -> int:
        ...
    def print(self, name: str = 'JunctionTree: ', formatter: typing.Callable[[int], str] = ...) -> None:
        ...
class DiscreteKeys:
    def __init__(self) -> None:
        ...
    def at(self, n: int) -> tuple[int, int]:
        ...
    def empty(self) -> bool:
        ...
    def push_back(self, point_pair: tuple[int, int]) -> None:
        ...
    def size(self) -> int:
        ...
class DiscreteLookupDAG:
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = 'DiscreteLookupDAG\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    @typing.overload
    def argmax(self) -> ...:
        ...
    @typing.overload
    def argmax(self, given: ...) -> ...:
        ...
    def at(self, i: int) -> DiscreteLookupTable:
        ...
    def empty(self) -> bool:
        ...
    def keys(self) -> ...:
        ...
    def print(self, s: str = 'DiscreteLookupDAG\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def push_back(self, table: DiscreteLookupTable) -> None:
        ...
    def size(self) -> int:
        ...
class DiscreteLookupTable(DiscreteConditional):
    def __init__(self, nFrontals: int, keys: DiscreteKeys, potentials: ...) -> None:
        ...
    def __repr__(self, s: str = 'Discrete Lookup Table: ', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def argmax(self, parentsValues: ...) -> int:
        ...
    def print(self, s: str = 'Discrete Lookup Table: ', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class DiscreteValues:
    def __bool__(self) -> bool:
        """
        Check whether the map is nonempty
        """
    @typing.overload
    def __contains__(self, arg0: int) -> bool:
        ...
    @typing.overload
    def __contains__(self, arg0: typing.Any) -> bool:
        ...
    def __delitem__(self, arg0: int) -> None:
        ...
    def __getitem__(self, arg0: int) -> int:
        ...
    def __init__(self) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self: dict[int, int]) -> int:
        ...
    def __repr__(self) -> str:
        """
        Return the canonical string representation of this map.
        """
    def __setitem__(self, arg0: int, arg1: int) -> None:
        ...
    def items(self) -> typing.ItemsView[int, int]:
        ...
    def keys(self) -> typing.KeysView[int]:
        ...
    def values(self) -> typing.ValuesView[int]:
        ...
class DoglegOptimizer(NonlinearOptimizer):
    @typing.overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: ...) -> None:
        ...
    @typing.overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: ..., params: DoglegParams) -> None:
        ...
    def getDelta(self) -> float:
        ...
class DoglegParams(NonlinearOptimizerParams):
    def __init__(self) -> None:
        ...
    def getDeltaInitial(self) -> float:
        ...
    def getVerbosityDL(self) -> str:
        ...
    def setDeltaInitial(self, deltaInitial: float) -> None:
        ...
    def setVerbosityDL(self, verbosityDL: str) -> None:
        ...
class DotWriter:
    binaryEdges: bool
    boxes: set[int]
    connectKeysToFactor: bool
    factorPositions: dict[int, numpy.ndarray[numpy.float64[2, 1]]]
    figureHeightInches: float
    figureWidthInches: float
    plotFactorPoints: bool
    positionHints: dict[str, float]
    variablePositions: dict[int, numpy.ndarray[numpy.float64[2, 1]]]
    def __init__(self, figureWidthInches: float = 5, figureHeightInches: float = 5, plotFactorPoints: bool = True, connectKeysToFactor: bool = True, binaryEdges: bool = True) -> None:
        ...
class DummyPreconditionerParameters(PreconditionerParameters):
    def __init__(self) -> None:
        ...
class EssentialMatrix:
    @staticmethod
    def Dim() -> int:
        ...
    @typing.overload
    def FromPose3(self, _1P2_: Pose3) -> EssentialMatrix:
        ...
    @typing.overload
    def FromPose3(self, _1P2_: Pose3, H: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> EssentialMatrix:
        ...
    def __init__(self, aRb: Rot3, aTb: Unit3) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def dim(self) -> int:
        ...
    def direction(self) -> Unit3:
        ...
    def equals(self, pose: EssentialMatrix, tol: float) -> bool:
        ...
    def error(self, vA: numpy.ndarray[numpy.float64[m, 1]], vB: numpy.ndarray[numpy.float64[m, 1]]) -> float:
        ...
    def localCoordinates(self, s: EssentialMatrix) -> numpy.ndarray[numpy.float64[5, 1]]:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> EssentialMatrix:
        ...
    def rotation(self) -> Rot3:
        ...
class EssentialMatrixConstraint(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, measuredE: EssentialMatrix, model: noiseModel.Base) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, other: EssentialMatrixConstraint, tol: float) -> bool:
        ...
    def evaluateError(self, p1: Pose3, p2: Pose3) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def measured(self) -> EssentialMatrix:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class EssentialMatrixFactor(NoiseModelFactor):
    def __init__(self, key: int, pA: numpy.ndarray[numpy.float64[2, 1]], pB: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, other: EssentialMatrixFactor, tol: float) -> bool:
        ...
    def evaluateError(self, E: EssentialMatrix) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class EvaluationFactorChebyshev1Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class EvaluationFactorChebyshev2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class EvaluationFactorChebyshev2Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class EvaluationFactorFourierBasis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class Factor:
    def __repr__(self, s: str = 'Factor\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, other: Factor, tol: float = 1e-09) -> bool:
        ...
    def keys(self) -> list[int]:
        ...
    def print(self, s: str = 'Factor\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def printKeys(self, s: str = '') -> None:
        ...
    def size(self) -> int:
        ...
class FitBasisChebyshev1Basis:
    @staticmethod
    def LinearGraph(sequence: dict[float, float], model: noiseModel.Base, N: int) -> GaussianFactorGraph:
        ...
    @staticmethod
    def NonlinearGraph(sequence: dict[float, float], model: noiseModel.Base, N: int) -> NonlinearFactorGraph:
        ...
    def __init__(self, sequence: dict[float, float], model: noiseModel.Base, N: int) -> None:
        ...
    def parameters(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class FitBasisChebyshev2:
    @staticmethod
    def LinearGraph(sequence: dict[float, float], model: noiseModel.Base, N: int) -> GaussianFactorGraph:
        ...
    @staticmethod
    def NonlinearGraph(sequence: dict[float, float], model: noiseModel.Base, N: int) -> NonlinearFactorGraph:
        ...
    def __init__(self, sequence: dict[float, float], model: noiseModel.Base, N: int) -> None:
        ...
    def parameters(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class FitBasisChebyshev2Basis:
    @staticmethod
    def LinearGraph(sequence: dict[float, float], model: noiseModel.Base, N: int) -> GaussianFactorGraph:
        ...
    @staticmethod
    def NonlinearGraph(sequence: dict[float, float], model: noiseModel.Base, N: int) -> NonlinearFactorGraph:
        ...
    def __init__(self, sequence: dict[float, float], model: noiseModel.Base, N: int) -> None:
        ...
    def parameters(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class FitBasisFourierBasis:
    @staticmethod
    def LinearGraph(sequence: dict[float, float], model: noiseModel.Base, N: int) -> GaussianFactorGraph:
        ...
    @staticmethod
    def NonlinearGraph(sequence: dict[float, float], model: noiseModel.Base, N: int) -> NonlinearFactorGraph:
        ...
    def __init__(self, sequence: dict[float, float], model: noiseModel.Base, N: int) -> None:
        ...
    def parameters(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class FixedLagSmoother:
    def __repr__(self, s: str) -> str:
        ...
    def calculateEstimate(self) -> ...:
        ...
    def equals(self, rhs: FixedLagSmoother, tol: float) -> bool:
        ...
    def print(self, s: str) -> None:
        ...
    def smootherLag(self) -> float:
        ...
    def timestamps(self) -> dict[int, float]:
        ...
    @typing.overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: ..., timestamps: dict[int, float]) -> FixedLagSmootherResult:
        ...
    @typing.overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: ..., timestamps: dict[int, float], factorsToRemove: list[int]) -> FixedLagSmootherResult:
        ...
class FixedLagSmootherResult:
    def getError(self) -> float:
        ...
    def getIterations(self) -> int:
        ...
    def getLinearVariables(self) -> int:
        ...
    def getNonlinearVariables(self) -> int:
        ...
class FourierBasis:
    @staticmethod
    def CalculateWeights(N: int, x: float) -> numpy.ndarray[numpy.float64[1, n]]:
        ...
    @staticmethod
    def DerivativeWeights(N: int, x: float) -> numpy.ndarray[numpy.float64[1, n]]:
        ...
    @staticmethod
    def DifferentiationMatrix(N: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @staticmethod
    def WeightMatrix(N: int, x: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
class FrobeniusBetweenFactorSO3(NoiseModelFactor):
    @typing.overload
    def __init__(self, key1: int, key2: int, R12: SO3) -> None:
        ...
    @typing.overload
    def __init__(self, key1: int, key2: int, R12: SO3, model: noiseModel.Base) -> None:
        ...
    def evaluateError(self, R1: SO3, R2: SO3) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class FrobeniusBetweenFactorSO4(NoiseModelFactor):
    @typing.overload
    def __init__(self, key1: int, key2: int, R12: SO4) -> None:
        ...
    @typing.overload
    def __init__(self, key1: int, key2: int, R12: SO4, model: noiseModel.Base) -> None:
        ...
    def evaluateError(self, R1: SO4, R2: SO4) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class FrobeniusFactorSO3(NoiseModelFactor):
    @typing.overload
    def __init__(self, key1: int, key2: int) -> None:
        ...
    @typing.overload
    def __init__(self, key1: int, key2: int, model: noiseModel.Base) -> None:
        ...
    def evaluateError(self, R1: SO3, R2: SO3) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class FrobeniusFactorSO4(NoiseModelFactor):
    @typing.overload
    def __init__(self, key1: int, key2: int) -> None:
        ...
    @typing.overload
    def __init__(self, key1: int, key2: int, model: noiseModel.Base) -> None:
        ...
    def evaluateError(self, R1: SO4, R2: SO4) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class GPSFactor(NonlinearFactor):
    def __init__(self, key: int, gpsIn: numpy.ndarray[numpy.float64[3, 1]], model: noiseModel.Base) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, expected: NonlinearFactor, tol: float) -> bool:
        ...
    def measurementIn(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class GPSFactor2(NonlinearFactor):
    def __init__(self, key: int, gpsIn: numpy.ndarray[numpy.float64[3, 1]], model: noiseModel.Base) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, expected: NonlinearFactor, tol: float) -> bool:
        ...
    def measurementIn(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class GaussNewtonOptimizer(NonlinearOptimizer):
    @typing.overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: ...) -> None:
        ...
    @typing.overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: ..., params: GaussNewtonParams) -> None:
        ...
class GaussNewtonParams(NonlinearOptimizerParams):
    def __init__(self) -> None:
        ...
class GaussianBayesNet:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, conditional: GaussianConditional) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def at(self, idx: int) -> GaussianConditional:
        ...
    def back(self) -> GaussianConditional:
        ...
    def backSubstitute(self, gx: VectorValues) -> VectorValues:
        ...
    def backSubstituteTranspose(self, gx: VectorValues) -> VectorValues:
        ...
    def determinant(self) -> float:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> str:
        ...
    def equals(self, other: GaussianBayesNet, tol: float) -> bool:
        ...
    @typing.overload
    def error(self, x: VectorValues) -> float:
        ...
    @typing.overload
    def error(self, x: VectorValues) -> float:
        ...
    def evaluate(self, x: VectorValues) -> float:
        ...
    def exists(self, idx: int) -> bool:
        ...
    def front(self) -> GaussianConditional:
        ...
    def gradient(self, x0: VectorValues) -> VectorValues:
        ...
    def gradientAtZero(self) -> VectorValues:
        ...
    def keyVector(self) -> list[int]:
        ...
    def keys(self) -> ...:
        ...
    def logDeterminant(self) -> float:
        ...
    def logProbability(self, x: VectorValues) -> float:
        ...
    def matrix(self) -> tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    @typing.overload
    def optimize(self) -> VectorValues:
        ...
    @typing.overload
    def optimize(self, given: VectorValues) -> VectorValues:
        ...
    def optimizeGradientSearch(self) -> VectorValues:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def push_back(self, conditional: GaussianConditional) -> None:
        ...
    @typing.overload
    def push_back(self, bayesNet: GaussianBayesNet) -> None:
        ...
    @typing.overload
    def sample(self, given: VectorValues) -> VectorValues:
        ...
    @typing.overload
    def sample(self) -> VectorValues:
        ...
    @typing.overload
    def saveGraph(self, s: str) -> None:
        ...
    @typing.overload
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> None:
        ...
    def size(self) -> int:
        ...
class GaussianBayesTree:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: GaussianBayesTree) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def determinant(self) -> float:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, other: GaussianBayesTree, tol: float) -> bool:
        ...
    def error(self, x: VectorValues) -> float:
        ...
    def gradient(self, x0: VectorValues) -> VectorValues:
        ...
    def gradientAtZero(self) -> VectorValues:
        ...
    def joint(self, key1: int, key2: int) -> GaussianFactorGraph:
        ...
    def jointBayesNet(self, key1: int, key2: int) -> GaussianBayesNet:
        ...
    def logDeterminant(self) -> float:
        ...
    def marginalCovariance(self, key: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def marginalFactor(self, key: int) -> GaussianConditional:
        ...
    def numCachedSeparatorMarginals(self) -> int:
        ...
    def optimize(self) -> VectorValues:
        ...
    def optimizeGradientSearch(self) -> VectorValues:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def size(self) -> int:
        ...
class GaussianConditional(JacobianFactor):
    @staticmethod
    @typing.overload
    def FromMeanAndStddev(key: int, mu: numpy.ndarray[numpy.float64[m, 1]], sigma: float) -> GaussianConditional:
        ...
    @staticmethod
    @typing.overload
    def FromMeanAndStddev(key: int, A: numpy.ndarray[numpy.float64[m, n]], parent: int, b: numpy.ndarray[numpy.float64[m, 1]], sigma: float) -> GaussianConditional:
        ...
    @staticmethod
    @typing.overload
    def FromMeanAndStddev(key: int, A1: numpy.ndarray[numpy.float64[m, n]], parent1: int, A2: numpy.ndarray[numpy.float64[m, n]], parent2: int, b: numpy.ndarray[numpy.float64[m, 1]], sigma: float) -> GaussianConditional:
        ...
    def R(self) -> numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.f_contiguous]:
        ...
    def S(self) -> numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.f_contiguous]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, key: int, d: numpy.ndarray[numpy.float64[m, 1]], R: numpy.ndarray[numpy.float64[m, n]], sigmas: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, d: numpy.ndarray[numpy.float64[m, 1]], R: numpy.ndarray[numpy.float64[m, n]], name1: int, S: numpy.ndarray[numpy.float64[m, n]], sigmas: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, d: numpy.ndarray[numpy.float64[m, 1]], R: numpy.ndarray[numpy.float64[m, n]], name1: int, S: numpy.ndarray[numpy.float64[m, n]], name2: int, T: numpy.ndarray[numpy.float64[m, n]], sigmas: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, d: numpy.ndarray[numpy.float64[m, 1]], R: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, d: numpy.ndarray[numpy.float64[m, 1]], R: numpy.ndarray[numpy.float64[m, n]], name1: int, S: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, d: numpy.ndarray[numpy.float64[m, 1]], R: numpy.ndarray[numpy.float64[m, n]], name1: int, S: numpy.ndarray[numpy.float64[m, n]], name2: int, T: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def __repr__(self, s: str = 'GaussianConditional', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def d(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, cg: GaussianConditional, tol: float) -> bool:
        ...
    @typing.overload
    def error(self, x: VectorValues) -> float:
        ...
    @typing.overload
    def error(self, x: ...) -> float:
        ...
    @typing.overload
    def evaluate(self, x: VectorValues) -> float:
        ...
    @typing.overload
    def evaluate(self, x: ...) -> float:
        ...
    def firstFrontalKey(self) -> int:
        ...
    @typing.overload
    def likelihood(self, frontalValues: VectorValues) -> JacobianFactor:
        ...
    @typing.overload
    def likelihood(self, frontal: numpy.ndarray[numpy.float64[m, 1]]) -> JacobianFactor:
        ...
    def logNormalizationConstant(self) -> float:
        ...
    @typing.overload
    def logProbability(self, x: VectorValues) -> float:
        ...
    @typing.overload
    def logProbability(self, x: ...) -> float:
        ...
    def print(self, s: str = 'GaussianConditional', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def sample(self, parents: VectorValues) -> VectorValues:
        ...
    @typing.overload
    def sample(self) -> VectorValues:
        ...
    def serialize(self) -> str:
        ...
    def solve(self, parents: VectorValues) -> VectorValues:
        ...
    def solveOtherRHS(self, parents: VectorValues, rhs: VectorValues) -> VectorValues:
        ...
    def solveTransposeInPlace(self, gy: VectorValues) -> None:
        ...
class GaussianDensity(GaussianConditional):
    @staticmethod
    def FromMeanAndStddev(key: int, mean: numpy.ndarray[numpy.float64[m, 1]], sigma: float) -> GaussianDensity:
        ...
    def __init__(self, key: int, d: numpy.ndarray[numpy.float64[m, 1]], R: numpy.ndarray[numpy.float64[m, n]], sigmas: noiseModel.Diagonal) -> None:
        ...
    def __repr__(self, s: str = 'GaussianDensity', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def covariance(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def equals(self, cg: GaussianDensity, tol: float) -> bool:
        ...
    def mean(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def print(self, s: str = 'GaussianDensity', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class GaussianFactor(Factor):
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def augmentedInformation(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def augmentedJacobian(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def clone(self) -> GaussianFactor:
        ...
    def equals(self, lf: GaussianFactor, tol: float) -> bool:
        ...
    def error(self, c: VectorValues) -> float:
        ...
    def information(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def jacobian(self) -> tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    def negate(self) -> GaussianFactor:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class GaussianFactorGraph:
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, bayesNet: ...) -> None:
        ...
    @typing.overload
    def __init__(self, bayesTree: ...) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def add(self, factor: GaussianFactor) -> None:
        ...
    @typing.overload
    def add(self, b: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def add(self, key1: int, A1: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def add(self, key1: int, A1: numpy.ndarray[numpy.float64[m, n]], key2: int, A2: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def add(self, key1: int, A1: numpy.ndarray[numpy.float64[m, n]], key2: int, A2: numpy.ndarray[numpy.float64[m, n]], key3: int, A3: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Diagonal) -> None:
        ...
    def at(self, idx: int) -> GaussianFactor:
        ...
    @typing.overload
    def augmentedHessian(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def augmentedHessian(self, ordering: Ordering) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def augmentedJacobian(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def augmentedJacobian(self, ordering: Ordering) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def clone(self) -> GaussianFactorGraph:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> str:
        ...
    @typing.overload
    def eliminateMultifrontal(self) -> ...:
        ...
    @typing.overload
    def eliminateMultifrontal(self, type: Ordering.OrderingType) -> ...:
        ...
    @typing.overload
    def eliminateMultifrontal(self, ordering: Ordering) -> ...:
        ...
    @typing.overload
    def eliminatePartialMultifrontal(self, ordering: Ordering) -> tuple[..., GaussianFactorGraph]:
        ...
    @typing.overload
    def eliminatePartialMultifrontal(self, keys: list[int]) -> tuple[..., GaussianFactorGraph]:
        ...
    @typing.overload
    def eliminatePartialSequential(self, ordering: Ordering) -> tuple[..., GaussianFactorGraph]:
        ...
    @typing.overload
    def eliminatePartialSequential(self, keys: list[int]) -> tuple[..., GaussianFactorGraph]:
        ...
    @typing.overload
    def eliminateSequential(self) -> ...:
        ...
    @typing.overload
    def eliminateSequential(self, type: Ordering.OrderingType) -> ...:
        ...
    @typing.overload
    def eliminateSequential(self, ordering: Ordering) -> ...:
        ...
    def equals(self, lfgraph: GaussianFactorGraph, tol: float) -> bool:
        ...
    def error(self, c: VectorValues) -> float:
        ...
    def exists(self, idx: int) -> bool:
        ...
    def gradient(self, x0: VectorValues) -> VectorValues:
        ...
    def gradientAtZero(self) -> VectorValues:
        ...
    @typing.overload
    def hessian(self) -> tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    @typing.overload
    def hessian(self, ordering: Ordering) -> tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    @typing.overload
    def jacobian(self) -> tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    @typing.overload
    def jacobian(self, ordering: Ordering) -> tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    def keyVector(self) -> list[int]:
        ...
    def keys(self) -> ...:
        ...
    def marginal(self, key_vector: list[int]) -> GaussianFactorGraph:
        ...
    @typing.overload
    def marginalMultifrontalBayesNet(self, ordering: Ordering) -> ...:
        ...
    @typing.overload
    def marginalMultifrontalBayesNet(self, key_vector: list[int]) -> ...:
        ...
    @typing.overload
    def marginalMultifrontalBayesNet(self, ordering: Ordering, marginalizedVariableOrdering: Ordering) -> ...:
        ...
    @typing.overload
    def marginalMultifrontalBayesNet(self, key_vector: list[int], marginalizedVariableOrdering: Ordering) -> ...:
        ...
    def negate(self) -> GaussianFactorGraph:
        ...
    @typing.overload
    def optimize(self) -> VectorValues:
        ...
    @typing.overload
    def optimize(self, ordering: Ordering) -> VectorValues:
        ...
    def optimizeDensely(self) -> VectorValues:
        ...
    def optimizeGradientSearch(self) -> VectorValues:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def printErrors(self, c: VectorValues, str: str = 'GaussianFactorGraph: ', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def probPrime(self, c: VectorValues) -> float:
        ...
    @typing.overload
    def push_back(self, factor: GaussianFactor) -> None:
        ...
    @typing.overload
    def push_back(self, conditional: ...) -> None:
        ...
    @typing.overload
    def push_back(self, graph: GaussianFactorGraph) -> None:
        ...
    @typing.overload
    def push_back(self, bayesNet: ...) -> None:
        ...
    @typing.overload
    def push_back(self, bayesTree: ...) -> None:
        ...
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> None:
        ...
    def serialize(self) -> str:
        ...
    def size(self) -> int:
        ...
    def sparseJacobian_(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
class GaussianISAM:
    def __init__(self) -> None:
        ...
    def clear(self) -> None:
        ...
    def saveGraph(self, s: str) -> None:
        ...
    def update(self, newFactors: GaussianFactorGraph) -> None:
        ...
class GaussianMixture(HybridFactor):
    def __init__(self, continuousFrontals: list[int], continuousParents: list[int], discreteParents: DiscreteKeys, conditionalsList: list[GaussianConditional]) -> None:
        ...
    def __repr__(self, s: str = 'GaussianMixture\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def likelihood(self, frontals: VectorValues) -> GaussianMixtureFactor:
        ...
    def print(self, s: str = 'GaussianMixture\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class GaussianMixtureFactor(HybridFactor):
    def __init__(self, continuousKeys: list[int], discreteKeys: DiscreteKeys, factorsList: list[GaussianFactor]) -> None:
        ...
    def __repr__(self, s: str = 'GaussianMixtureFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def print(self, s: str = 'GaussianMixtureFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class GeneralSFMFactor2Cal3Bundler(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, poseKey: int, landmarkKey: int, calibKey: int) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
class GeneralSFMFactor2Cal3DS2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, poseKey: int, landmarkKey: int, calibKey: int) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
class GeneralSFMFactor2Cal3Fisheye(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, poseKey: int, landmarkKey: int, calibKey: int) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
class GeneralSFMFactor2Cal3Unified(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, poseKey: int, landmarkKey: int, calibKey: int) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
class GeneralSFMFactor2Cal3_S2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, poseKey: int, landmarkKey: int, calibKey: int) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
class GeneralSFMFactorCal3Bundler(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GeneralSFMFactorCal3DS2(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GeneralSFMFactorCal3Fisheye(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GeneralSFMFactorCal3Unified(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GeneralSFMFactorCal3_S2(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GeneralSFMFactorPoseCal3Bundler(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GeneralSFMFactorPoseCal3DS2(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GeneralSFMFactorPoseCal3Fisheye(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GeneralSFMFactorPoseCal3Unified(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GeneralSFMFactorPoseCal3_S2(NoiseModelFactor):
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], model: noiseModel.Base, cameraKey: int, landmarkKey: int) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class GenericProjectionFactorCal3DS2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3DS2) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3DS2, body_P_sensor: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3DS2, throwCheirality: bool, verboseCheirality: bool) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3DS2, throwCheirality: bool, verboseCheirality: bool, body_P_sensor: Pose3) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def calibration(self) -> Cal3DS2:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
    def throwCheirality(self) -> bool:
        ...
    def verboseCheirality(self) -> bool:
        ...
class GenericProjectionFactorCal3Fisheye(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3Fisheye) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3Fisheye, body_P_sensor: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3Fisheye, throwCheirality: bool, verboseCheirality: bool) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3Fisheye, throwCheirality: bool, verboseCheirality: bool, body_P_sensor: Pose3) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def calibration(self) -> Cal3Fisheye:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
    def throwCheirality(self) -> bool:
        ...
    def verboseCheirality(self) -> bool:
        ...
class GenericProjectionFactorCal3Unified(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3Unified) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3Unified, body_P_sensor: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3Unified, throwCheirality: bool, verboseCheirality: bool) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3Unified, throwCheirality: bool, verboseCheirality: bool, body_P_sensor: Pose3) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def calibration(self) -> Cal3Unified:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
    def throwCheirality(self) -> bool:
        ...
    def verboseCheirality(self) -> bool:
        ...
class GenericProjectionFactorCal3_S2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3_S2) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3_S2, body_P_sensor: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3_S2, throwCheirality: bool, verboseCheirality: bool) -> None:
        ...
    @typing.overload
    def __init__(self, measured: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base, poseKey: int, pointKey: int, k: Cal3_S2, throwCheirality: bool, verboseCheirality: bool, body_P_sensor: Pose3) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def calibration(self) -> Cal3_S2:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
    def throwCheirality(self) -> bool:
        ...
    def verboseCheirality(self) -> bool:
        ...
class GenericStereoFactor3D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, measured: StereoPoint2, noiseModel: noiseModel.Base, poseKey: int, landmarkKey: int, K: Cal3_S2Stereo) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def calibration(self) -> Cal3_S2Stereo:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> StereoPoint2:
        ...
    def serialize(self) -> str:
        ...
class GenericValueCal3Bundler(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueCal3DS2(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueCal3Fisheye(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueCal3Unified(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueCal3_S2(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueCalibratedCamera(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueConstantBias(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueEssentialMatrix(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueMatrix(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValuePoint2(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValuePoint3(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValuePose2(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValuePose3(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueRot2(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueRot3(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueStereoPoint2(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GenericValueVector(Value):
    def __getstate__(self) -> tuple:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class GncGaussNewtonOptimizer:
    def __init__(self, graph: NonlinearFactorGraph, initialValues: ..., params: GncGaussNewtonParams) -> None:
        ...
    def getInlierCostThresholds(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getWeights(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def optimize(self) -> ...:
        ...
    def setInlierCostThresholds(self, inth: float) -> None:
        ...
    def setInlierCostThresholdsAtProbability(self, alpha: float) -> None:
        ...
    def setWeights(self, w: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class GncGaussNewtonParams:
    class Verbosity:
        """
        Members:
        
          SILENT
        
          SUMMARY
        
          VALUES
        """
        SILENT: typing.ClassVar[GncGaussNewtonParams.Verbosity]  # value = <Verbosity.SILENT: 0>
        SUMMARY: typing.ClassVar[GncGaussNewtonParams.Verbosity]  # value = <Verbosity.SUMMARY: 1>
        VALUES: typing.ClassVar[GncGaussNewtonParams.Verbosity]  # value = <Verbosity.VALUES: 4>
        __members__: typing.ClassVar[dict[str, GncGaussNewtonParams.Verbosity]]  # value = {'SILENT': <Verbosity.SILENT: 0>, 'SUMMARY': <Verbosity.SUMMARY: 1>, 'VALUES': <Verbosity.VALUES: 4>}
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    baseOptimizerParams: GaussNewtonParams
    knownInliers: list[int]
    knownOutliers: list[int]
    lossType: GncLossType
    maxIterations: int
    muStep: float
    relativeCostTol: float
    verbosity: ...
    weightsTol: float
    @typing.overload
    def __init__(self, baseOptimizerParams: GaussNewtonParams) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def __repr__(self, str: str = 'GncParams: ') -> str:
        ...
    def print(self, str: str = 'GncParams: ') -> None:
        ...
    def setKnownInliers(self, knownIn: list[int]) -> None:
        ...
    def setKnownOutliers(self, knownOut: list[int]) -> None:
        ...
    def setLossType(self, type: GncLossType) -> None:
        ...
    def setMaxIterations(self, maxIter: int) -> None:
        ...
    def setMuStep(self, step: float) -> None:
        ...
    def setRelativeCostTol(self, value: float) -> None:
        ...
    def setVerbosityGNC(self, value: ...) -> None:
        ...
    def setWeightsTol(self, value: float) -> None:
        ...
class GncLMOptimizer:
    def __init__(self, graph: NonlinearFactorGraph, initialValues: ..., params: GncLMParams) -> None:
        ...
    def getInlierCostThresholds(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getWeights(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def optimize(self) -> ...:
        ...
    def setInlierCostThresholds(self, inth: float) -> None:
        ...
    def setInlierCostThresholdsAtProbability(self, alpha: float) -> None:
        ...
    def setWeights(self, w: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class GncLMParams:
    class Verbosity:
        """
        Members:
        
          SILENT
        
          SUMMARY
        
          VALUES
        """
        SILENT: typing.ClassVar[GncLMParams.Verbosity]  # value = <Verbosity.SILENT: 0>
        SUMMARY: typing.ClassVar[GncLMParams.Verbosity]  # value = <Verbosity.SUMMARY: 1>
        VALUES: typing.ClassVar[GncLMParams.Verbosity]  # value = <Verbosity.VALUES: 4>
        __members__: typing.ClassVar[dict[str, GncLMParams.Verbosity]]  # value = {'SILENT': <Verbosity.SILENT: 0>, 'SUMMARY': <Verbosity.SUMMARY: 1>, 'VALUES': <Verbosity.VALUES: 4>}
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    baseOptimizerParams: LevenbergMarquardtParams
    knownInliers: list[int]
    knownOutliers: list[int]
    lossType: GncLossType
    maxIterations: int
    muStep: float
    relativeCostTol: float
    verbosity: ...
    weightsTol: float
    @typing.overload
    def __init__(self, baseOptimizerParams: LevenbergMarquardtParams) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def __repr__(self, str: str = 'GncParams: ') -> str:
        ...
    def print(self, str: str = 'GncParams: ') -> None:
        ...
    def setKnownInliers(self, knownIn: list[int]) -> None:
        ...
    def setKnownOutliers(self, knownOut: list[int]) -> None:
        ...
    def setLossType(self, type: GncLossType) -> None:
        ...
    def setMaxIterations(self, maxIter: int) -> None:
        ...
    def setMuStep(self, step: float) -> None:
        ...
    def setRelativeCostTol(self, value: float) -> None:
        ...
    def setVerbosityGNC(self, value: ...) -> None:
        ...
    def setWeightsTol(self, value: float) -> None:
        ...
class GncLossType:
    """
    Members:
    
      GM
    
      TLS
    """
    GM: typing.ClassVar[GncLossType]  # value = <GncLossType.GM: 0>
    TLS: typing.ClassVar[GncLossType]  # value = <GncLossType.TLS: 1>
    __members__: typing.ClassVar[dict[str, GncLossType]]  # value = {'GM': <GncLossType.GM: 0>, 'TLS': <GncLossType.TLS: 1>}
    def __and__(self, other: typing.Any) -> typing.Any:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __invert__(self) -> typing.Any:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __or__(self, other: typing.Any) -> typing.Any:
        ...
    def __rand__(self, other: typing.Any) -> typing.Any:
        ...
    def __repr__(self) -> str:
        ...
    def __ror__(self, other: typing.Any) -> typing.Any:
        ...
    def __rxor__(self, other: typing.Any) -> typing.Any:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __xor__(self, other: typing.Any) -> typing.Any:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class GraphvizFormatting(DotWriter):
    class Axis:
        """
        Members:
        
          X
        
          Y
        
          Z
        
          NEGX
        
          NEGY
        
          NEGZ
        """
        NEGX: typing.ClassVar[GraphvizFormatting.Axis]  # value = <Axis.NEGX: 3>
        NEGY: typing.ClassVar[GraphvizFormatting.Axis]  # value = <Axis.NEGY: 4>
        NEGZ: typing.ClassVar[GraphvizFormatting.Axis]  # value = <Axis.NEGZ: 5>
        X: typing.ClassVar[GraphvizFormatting.Axis]  # value = <Axis.X: 0>
        Y: typing.ClassVar[GraphvizFormatting.Axis]  # value = <Axis.Y: 1>
        Z: typing.ClassVar[GraphvizFormatting.Axis]  # value = <Axis.Z: 2>
        __members__: typing.ClassVar[dict[str, GraphvizFormatting.Axis]]  # value = {'X': <Axis.X: 0>, 'Y': <Axis.Y: 1>, 'Z': <Axis.Z: 2>, 'NEGX': <Axis.NEGX: 3>, 'NEGY': <Axis.NEGY: 4>, 'NEGZ': <Axis.NEGZ: 5>}
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    mergeSimilarFactors: bool
    paperHorizontalAxis: ...
    paperVerticalAxis: ...
    scale: float
    def __init__(self) -> None:
        ...
class HessianFactor(GaussianFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, factor: GaussianFactor) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, G: numpy.ndarray[numpy.float64[m, n]], g: numpy.ndarray[numpy.float64[m, 1]], f: float) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, mu: numpy.ndarray[numpy.float64[m, 1]], Sigma: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def __init__(self, j1: int, j2: int, G11: numpy.ndarray[numpy.float64[m, n]], G12: numpy.ndarray[numpy.float64[m, n]], g1: numpy.ndarray[numpy.float64[m, 1]], G22: numpy.ndarray[numpy.float64[m, n]], g2: numpy.ndarray[numpy.float64[m, 1]], f: float) -> None:
        ...
    @typing.overload
    def __init__(self, j1: int, j2: int, j3: int, G11: numpy.ndarray[numpy.float64[m, n]], G12: numpy.ndarray[numpy.float64[m, n]], G13: numpy.ndarray[numpy.float64[m, n]], g1: numpy.ndarray[numpy.float64[m, 1]], G22: numpy.ndarray[numpy.float64[m, n]], G23: numpy.ndarray[numpy.float64[m, n]], g2: numpy.ndarray[numpy.float64[m, 1]], G33: numpy.ndarray[numpy.float64[m, n]], g3: numpy.ndarray[numpy.float64[m, 1]], f: float) -> None:
        ...
    @typing.overload
    def __init__(self, factors: ...) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def constantTerm(self) -> float:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, lf: GaussianFactor, tol: float) -> bool:
        ...
    def error(self, c: VectorValues) -> float:
        ...
    def information(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def linearTerm(self) -> numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def rows(self) -> int:
        ...
    def serialize(self) -> str:
        ...
class HybridBayesNet:
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = 'HybridBayesNet\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def at(self, i: int) -> HybridConditional:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, other: HybridBayesNet, tol: float = 1e-09) -> bool:
        ...
    def error(self, values: HybridValues) -> float:
        ...
    def evaluate(self, values: HybridValues) -> float:
        ...
    def keys(self) -> ...:
        ...
    def logProbability(self, values: HybridValues) -> float:
        ...
    def optimize(self) -> HybridValues:
        ...
    def print(self, s: str = 'HybridBayesNet\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def push_back(self, s: GaussianMixture) -> None:
        ...
    @typing.overload
    def push_back(self, s: GaussianConditional) -> None:
        ...
    @typing.overload
    def push_back(self, s: DiscreteConditional) -> None:
        ...
    @typing.overload
    def sample(self, given: HybridValues) -> HybridValues:
        ...
    @typing.overload
    def sample(self) -> HybridValues:
        ...
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> None:
        ...
    def size(self) -> int:
        ...
    def toFactorGraph(self, measurements: VectorValues) -> ...:
        ...
class HybridBayesTree:
    def __getitem__(self, arg0: int) -> HybridBayesTreeClique:
        ...
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = 'HybridBayesTree\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, other: HybridBayesTree, tol: float = 1e-09) -> bool:
        ...
    def optimize(self) -> HybridValues:
        ...
    def print(self, s: str = 'HybridBayesTree\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def size(self) -> int:
        ...
class HybridBayesTreeClique:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, conditional: HybridConditional) -> None:
        ...
    def conditional(self) -> HybridConditional:
        ...
    def isRoot(self) -> bool:
        ...
class HybridConditional:
    def __call__(self, arg0: HybridValues) -> float:
        ...
    def __repr__(self, s: str = 'Hybrid Conditional\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def asDiscrete(self) -> DiscreteConditional:
        ...
    def asGaussian(self) -> GaussianConditional:
        ...
    def asMixture(self) -> ...:
        ...
    def equals(self, other: HybridConditional, tol: float = 1e-09) -> bool:
        ...
    def error(self, values: HybridValues) -> float:
        ...
    def evaluate(self, values: HybridValues) -> float:
        ...
    def inner(self) -> Factor:
        ...
    def logNormalizationConstant(self) -> float:
        ...
    def logProbability(self, values: HybridValues) -> float:
        ...
    def nrFrontals(self) -> int:
        ...
    def nrParents(self) -> int:
        ...
    def print(self, s: str = 'Hybrid Conditional\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class HybridFactor(Factor):
    def __repr__(self, s: str = 'HybridFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def continuousKeys(self) -> list[int]:
        ...
    def discreteKeys(self) -> DiscreteKeys:
        ...
    def equals(self, other: HybridFactor, tol: float = 1e-09) -> bool:
        ...
    def error(self, values: HybridValues) -> float:
        ...
    def isContinuous(self) -> bool:
        ...
    def isDiscrete(self) -> bool:
        ...
    def isHybrid(self) -> bool:
        ...
    def nrContinuous(self) -> int:
        ...
    def print(self, s: str = 'HybridFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class HybridGaussianFactorGraph:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, bayesNet: HybridBayesNet) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def at(self, i: int) -> Factor:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> str:
        ...
    @typing.overload
    def eliminateMultifrontal(self) -> HybridBayesTree:
        ...
    @typing.overload
    def eliminateMultifrontal(self, type: Ordering.OrderingType) -> HybridBayesTree:
        ...
    @typing.overload
    def eliminateMultifrontal(self, ordering: Ordering) -> HybridBayesTree:
        ...
    def eliminatePartialMultifrontal(self, ordering: Ordering) -> tuple[HybridBayesTree, HybridGaussianFactorGraph]:
        ...
    def eliminatePartialSequential(self, ordering: Ordering) -> tuple[HybridBayesNet, HybridGaussianFactorGraph]:
        ...
    @typing.overload
    def eliminateSequential(self) -> HybridBayesNet:
        ...
    @typing.overload
    def eliminateSequential(self, type: Ordering.OrderingType) -> HybridBayesNet:
        ...
    @typing.overload
    def eliminateSequential(self, ordering: Ordering) -> HybridBayesNet:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, fg: HybridGaussianFactorGraph, tol: float = 1e-09) -> bool:
        ...
    def error(self, values: HybridValues) -> float:
        ...
    def keys(self) -> ...:
        ...
    def print(self, s: str = '') -> None:
        ...
    def probPrime(self, values: HybridValues) -> float:
        ...
    @typing.overload
    def push_back(self, factor: HybridFactor) -> None:
        ...
    @typing.overload
    def push_back(self, conditional: HybridConditional) -> None:
        ...
    @typing.overload
    def push_back(self, graph: HybridGaussianFactorGraph) -> None:
        ...
    @typing.overload
    def push_back(self, bayesNet: HybridBayesNet) -> None:
        ...
    @typing.overload
    def push_back(self, bayesTree: HybridBayesTree) -> None:
        ...
    @typing.overload
    def push_back(self, gmm: GaussianMixtureFactor) -> None:
        ...
    @typing.overload
    def push_back(self, factor: DecisionTreeFactor) -> None:
        ...
    @typing.overload
    def push_back(self, factor: ...) -> None:
        ...
    @typing.overload
    def push_back(self, factor: JacobianFactor) -> None:
        ...
    def remove(self, i: int) -> None:
        ...
    def size(self) -> int:
        ...
class HybridNonlinearFactorGraph:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, graph: HybridNonlinearFactorGraph) -> None:
        ...
    def __repr__(self, s: str = 'HybridNonlinearFactorGraph\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def at(self, i: int) -> Factor:
        ...
    def empty(self) -> bool:
        ...
    def keys(self) -> ...:
        ...
    def linearize(self, continuousValues: Values) -> HybridGaussianFactorGraph:
        ...
    def print(self, s: str = 'HybridNonlinearFactorGraph\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def push_back(self, factor: HybridFactor) -> None:
        ...
    @typing.overload
    def push_back(self, factor: NonlinearFactor) -> None:
        ...
    @typing.overload
    def push_back(self, factor: DiscreteFactor) -> None:
        ...
    def remove(self, i: int) -> None:
        ...
    def size(self) -> int:
        ...
class HybridValues:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, cv: VectorValues, dv: DiscreteValues) -> None:
        ...
    def __repr__(self, s: str = 'HybridValues', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def at(self, j: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def atDiscrete(self, j: int) -> int:
        ...
    def continuous(self) -> VectorValues:
        ...
    def discrete(self) -> DiscreteValues:
        ...
    def equals(self, other: HybridValues, tol: float) -> bool:
        ...
    @typing.overload
    def insert(self, j: int, value: int) -> None:
        ...
    @typing.overload
    def insert(self, j: int, value: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def insert(self, values: VectorValues) -> None:
        ...
    @typing.overload
    def insert(self, values: DiscreteValues) -> None:
        ...
    @typing.overload
    def insert(self, values: HybridValues) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, value: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, value: int) -> None:
        ...
    def print(self, s: str = 'HybridValues', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def update(self, values: VectorValues) -> None:
        ...
    @typing.overload
    def update(self, values: DiscreteValues) -> None:
        ...
    @typing.overload
    def update(self, values: HybridValues) -> None:
        ...
class ISAM2:
    @staticmethod
    @typing.overload
    def update(*args, **kwargs) -> ISAM2Result:
        ...
    @staticmethod
    @typing.overload
    def update(*args, **kwargs) -> ISAM2Result:
        ...
    @staticmethod
    @typing.overload
    def update(*args, **kwargs) -> ISAM2Result:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, params: ISAM2Params) -> None:
        ...
    @typing.overload
    def __init__(self, other: ISAM2) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def calculateBestEstimate(self) -> ...:
        ...
    def calculateEstimate(self) -> ...:
        ...
    def calculateEstimateCal3Bundler(self, key: int) -> Cal3Bundler:
        ...
    def calculateEstimateCal3DS2(self, key: int) -> Cal3DS2:
        ...
    def calculateEstimateCal3_S2(self, key: int) -> Cal3_S2:
        ...
    def calculateEstimateEssentialMatrix(self, key: int) -> EssentialMatrix:
        ...
    def calculateEstimateMatrix(self, key: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def calculateEstimatePinholeCameraCal3Bundler(self, key: int) -> PinholeCameraCal3Bundler:
        ...
    def calculateEstimatePinholeCameraCal3Fisheye(self, key: int) -> PinholeCameraCal3Fisheye:
        ...
    def calculateEstimatePinholeCameraCal3Unified(self, key: int) -> PinholeCameraCal3Unified:
        ...
    def calculateEstimatePinholeCameraCal3_S2(self, key: int) -> PinholeCameraCal3_S2:
        ...
    def calculateEstimatePoint2(self, key: int) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def calculateEstimatePoint3(self, key: int) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calculateEstimatePose2(self, key: int) -> Pose2:
        ...
    def calculateEstimatePose3(self, key: int) -> Pose3:
        ...
    def calculateEstimateRot2(self, key: int) -> Rot2:
        ...
    def calculateEstimateRot3(self, key: int) -> Rot3:
        ...
    def calculateEstimateVector(self, key: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, other: ISAM2, tol: float) -> bool:
        ...
    @typing.overload
    def error(self, values: VectorValues) -> float:
        ...
    @typing.overload
    def error(self, x: VectorValues) -> float:
        ...
    def getDelta(self) -> VectorValues:
        ...
    def getFactorsUnsafe(self) -> NonlinearFactorGraph:
        ...
    def getFixedVariables(self) -> ...:
        ...
    def getLinearizationPoint(self) -> ...:
        ...
    def getVariableIndex(self) -> VariableIndex:
        ...
    def gradientAtZero(self) -> VectorValues:
        ...
    def marginalCovariance(self, key: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def params(self) -> ISAM2Params:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def printStats(self) -> None:
        ...
    @typing.overload
    def printStats(self) -> None:
        ...
    @typing.overload
    def saveGraph(self, s: str) -> None:
        ...
    @typing.overload
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def update(self) -> ISAM2Result:
        ...
    @typing.overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: ...) -> ISAM2Result:
        ...
    @typing.overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: ..., removeFactorIndices: list[int]) -> ISAM2Result:
        ...
    @typing.overload
    def update(self, newFactors: NonlinearFactorGraph, newTheta: ..., updateParams: ...) -> ISAM2Result:
        ...
    def valueExists(self, key: int) -> bool:
        ...
class ISAM2Clique:
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def gradientContribution(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class ISAM2DoglegParams:
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def getAdaptationMode(self) -> str:
        ...
    def getInitialDelta(self) -> float:
        ...
    def getWildfireThreshold(self) -> float:
        ...
    def isVerbose(self) -> bool:
        ...
    def print(self, s: str = '') -> None:
        ...
    def setAdaptationMode(self, adaptationMode: str) -> None:
        ...
    def setInitialDelta(self, initialDelta: float) -> None:
        ...
    def setVerbose(self, verbose: bool) -> None:
        ...
    def setWildfireThreshold(self, wildfireThreshold: float) -> None:
        ...
class ISAM2GaussNewtonParams:
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def getWildfireThreshold(self) -> float:
        ...
    def print(self, s: str = '') -> None:
        ...
    def setWildfireThreshold(self, wildfireThreshold: float) -> None:
        ...
class ISAM2Params:
    class Factorization:
        """
        Members:
        
          CHOLESKY
        
          QR
        """
        CHOLESKY: typing.ClassVar[ISAM2Params.Factorization]  # value = <Factorization.CHOLESKY: 0>
        QR: typing.ClassVar[ISAM2Params.Factorization]  # value = <Factorization.QR: 1>
        __members__: typing.ClassVar[dict[str, ISAM2Params.Factorization]]  # value = {'CHOLESKY': <Factorization.CHOLESKY: 0>, 'QR': <Factorization.QR: 1>}
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    cacheLinearizedFactors: bool
    enableDetailedResults: bool
    enablePartialRelinearizationCheck: bool
    enableRelinearization: bool
    evaluateNonlinearError: bool
    factorization: ...
    findUnusedFactorSlots: bool
    relinearizeSkip: int
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def getFactorization(self) -> str:
        ...
    def print(self, s: str = '') -> None:
        ...
    def setFactorization(self, factorization: str) -> None:
        ...
    @typing.overload
    def setOptimizationParams(self, gauss_newton__params: ISAM2GaussNewtonParams) -> None:
        ...
    @typing.overload
    def setOptimizationParams(self, dogleg_params: ISAM2DoglegParams) -> None:
        ...
    @typing.overload
    def setRelinearizeThreshold(self, threshold: float) -> None:
        ...
    @typing.overload
    def setRelinearizeThreshold(self, threshold_map: ISAM2ThresholdMap) -> None:
        ...
class ISAM2Result:
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def getCliques(self) -> int:
        ...
    def getErrorAfter(self) -> float:
        ...
    def getErrorBefore(self) -> float:
        ...
    def getNewFactorsIndices(self) -> list[int]:
        ...
    def getVariablesReeliminated(self) -> int:
        ...
    def getVariablesRelinearized(self) -> int:
        ...
    def print(self, s: str = '') -> None:
        ...
class ISAM2ThresholdMap:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: ISAM2ThresholdMap) -> None:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def insert(self, value: tuple[str, numpy.ndarray[numpy.float64[m, 1]]]) -> None:
        ...
    def size(self) -> int:
        ...
class ImuFactor(NonlinearFactor):
    def __init__(self, pose_i: int, vel_i: int, pose_j: int, vel_j: int, bias: int, preintegratedMeasurements: PreintegratedImuMeasurements) -> None:
        ...
    def evaluateError(self, pose_i: Pose3, vel_i: numpy.ndarray[numpy.float64[m, 1]], pose_j: Pose3, vel_j: numpy.ndarray[numpy.float64[m, 1]], bias: imuBias.ConstantBias) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def preintegratedMeasurements(self) -> PreintegratedImuMeasurements:
        ...
class IndexPair:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, i: int, j: int) -> None:
        ...
    def i(self) -> int:
        ...
    def j(self) -> int:
        ...
class InitializePose3:
    @staticmethod
    def buildPose3graph(graph: NonlinearFactorGraph) -> NonlinearFactorGraph:
        ...
    @staticmethod
    def computeOrientationsChordal(pose3Graph: NonlinearFactorGraph) -> Values:
        ...
    @staticmethod
    @typing.overload
    def computeOrientationsGradient(pose3Graph: NonlinearFactorGraph, givenGuess: Values, maxIter: int, setRefFrame: bool) -> Values:
        ...
    @staticmethod
    @typing.overload
    def computeOrientationsGradient(pose3Graph: NonlinearFactorGraph, givenGuess: Values) -> Values:
        ...
    @staticmethod
    @typing.overload
    def initialize(graph: NonlinearFactorGraph, givenGuess: Values, useGradient: bool) -> Values:
        ...
    @staticmethod
    @typing.overload
    def initialize(graph: NonlinearFactorGraph) -> Values:
        ...
    @staticmethod
    def initializeOrientations(graph: NonlinearFactorGraph) -> Values:
        ...
class IterativeOptimizationParameters:
    def getVerbosity(self) -> str:
        ...
    def setVerbosity(self, s: str) -> None:
        ...
class JacobianFactor(GaussianFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, b_in: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, i1: int, A1: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def __init__(self, i1: int, A1: numpy.ndarray[numpy.float64[m, n]], i2: int, A2: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def __init__(self, i1: int, A1: numpy.ndarray[numpy.float64[m, n]], i2: int, A2: numpy.ndarray[numpy.float64[m, n]], i3: int, A3: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def __init__(self, graph: ...) -> None:
        ...
    @typing.overload
    def __init__(self, graph: ..., p_variableSlots: ...) -> None:
        ...
    @typing.overload
    def __init__(self, graph: ..., ordering: Ordering) -> None:
        ...
    @typing.overload
    def __init__(self, graph: ..., ordering: Ordering, p_variableSlots: ...) -> None:
        ...
    @typing.overload
    def __init__(self, factor: GaussianFactor) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def augmentedJacobianUnweighted(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def cols(self) -> int:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def eliminate(self, keys: Ordering) -> tuple[..., JacobianFactor]:
        ...
    def equals(self, lf: GaussianFactor, tol: float) -> bool:
        ...
    def error(self, c: VectorValues) -> float:
        ...
    def error_vector(self, c: VectorValues) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def getA(self) -> numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]:
        ...
    def get_model(self) -> noiseModel.Diagonal:
        ...
    def getb(self) -> numpy.ndarray[numpy.float64[m, 1], numpy.ndarray.flags.writeable]:
        ...
    def isConstrained(self) -> bool:
        ...
    def jacobianUnweighted(self) -> tuple[numpy.ndarray[numpy.float64[m, n]], numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def rows(self) -> int:
        ...
    def serialize(self) -> str:
        ...
    def setModel(self, anyConstrained: bool, sigmas: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def transposeMultiplyAdd(self, alpha: float, e: numpy.ndarray[numpy.float64[m, 1]], x: VectorValues) -> None:
        ...
    def unweighted_error(self, c: VectorValues) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def whiten(self) -> JacobianFactor:
        ...
class JacobianVector:
    __hash__: typing.ClassVar[None] = None
    def __bool__(self) -> bool:
        """
        Check whether the list is nonempty
        """
    def __contains__(self, x: numpy.ndarray[numpy.float64[m, n]]) -> bool:
        """
        Return true the container contains ``x``
        """
    @typing.overload
    def __delitem__(self, arg0: int) -> None:
        """
        Delete the list elements at index ``i``
        """
    @typing.overload
    def __delitem__(self, arg0: slice) -> None:
        """
        Delete list elements using a slice object
        """
    def __eq__(self, arg0: JacobianVector) -> bool:
        ...
    @typing.overload
    def __getitem__(self, s: slice) -> JacobianVector:
        """
        Retrieve list elements using a slice object
        """
    @typing.overload
    def __getitem__(self, arg0: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, arg0: JacobianVector) -> None:
        """
        Copy constructor
        """
    @typing.overload
    def __init__(self, arg0: typing.Iterable) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __ne__(self, arg0: JacobianVector) -> bool:
        ...
    def __repr__(self) -> str:
        """
        Return the canonical string representation of this list.
        """
    @typing.overload
    def __setitem__(self, arg0: int, arg1: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def __setitem__(self, arg0: slice, arg1: JacobianVector) -> None:
        """
        Assign list elements using a slice object
        """
    def append(self, x: numpy.ndarray[numpy.float64[m, n]]) -> None:
        """
        Add an item to the end of the list
        """
    def clear(self) -> None:
        """
        Clear the contents
        """
    def count(self, x: numpy.ndarray[numpy.float64[m, n]]) -> int:
        """
        Return the number of times ``x`` appears in the list
        """
    @typing.overload
    def extend(self, L: JacobianVector) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    @typing.overload
    def extend(self, L: typing.Iterable) -> None:
        """
        Extend the list by appending all the items in the given list
        """
    def insert(self, i: int, x: numpy.ndarray[numpy.float64[m, n]]) -> None:
        """
        Insert an item at a given position.
        """
    @typing.overload
    def pop(self) -> numpy.ndarray[numpy.float64[m, n]]:
        """
        Remove and return the last item
        """
    @typing.overload
    def pop(self, i: int) -> numpy.ndarray[numpy.float64[m, n]]:
        """
        Remove and return the item at index ``i``
        """
    def remove(self, x: numpy.ndarray[numpy.float64[m, n]]) -> None:
        """
        Remove the first item from the list whose value is x. It is an error if there is no such item.
        """
class JointMarginal:
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def at(self, iVariable: int, jVariable: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def fullMatrix(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class KalmanFilter:
    @staticmethod
    def step(p: GaussianDensity) -> int:
        ...
    def __init__(self, n: int) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def init(self, x0: numpy.ndarray[numpy.float64[m, 1]], P0: numpy.ndarray[numpy.float64[m, n]]) -> GaussianDensity:
        ...
    def predict(self, p: GaussianDensity, F: numpy.ndarray[numpy.float64[m, n]], B: numpy.ndarray[numpy.float64[m, n]], u: numpy.ndarray[numpy.float64[m, 1]], modelQ: noiseModel.Diagonal) -> GaussianDensity:
        ...
    def predict2(self, p: GaussianDensity, A0: numpy.ndarray[numpy.float64[m, n]], A1: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Diagonal) -> GaussianDensity:
        ...
    def predictQ(self, p: GaussianDensity, F: numpy.ndarray[numpy.float64[m, n]], B: numpy.ndarray[numpy.float64[m, n]], u: numpy.ndarray[numpy.float64[m, 1]], Q: numpy.ndarray[numpy.float64[m, n]]) -> GaussianDensity:
        ...
    def print(self, s: str = '') -> None:
        ...
    def update(self, p: GaussianDensity, H: numpy.ndarray[numpy.float64[m, n]], z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Diagonal) -> GaussianDensity:
        ...
    def updateQ(self, p: GaussianDensity, H: numpy.ndarray[numpy.float64[m, n]], z: numpy.ndarray[numpy.float64[m, 1]], Q: numpy.ndarray[numpy.float64[m, n]]) -> GaussianDensity:
        ...
class KarcherMeanFactorPoint2(NonlinearFactor):
    def __init__(self, keys: list[int]) -> None:
        ...
class KarcherMeanFactorPoint3(NonlinearFactor):
    def __init__(self, keys: list[int]) -> None:
        ...
class KarcherMeanFactorPose2(NonlinearFactor):
    def __init__(self, keys: list[int]) -> None:
        ...
class KarcherMeanFactorPose3(NonlinearFactor):
    def __init__(self, keys: list[int]) -> None:
        ...
class KarcherMeanFactorRot2(NonlinearFactor):
    def __init__(self, keys: list[int]) -> None:
        ...
class KarcherMeanFactorRot3(NonlinearFactor):
    def __init__(self, keys: list[int]) -> None:
        ...
class KarcherMeanFactorSO3(NonlinearFactor):
    def __init__(self, keys: list[int]) -> None:
        ...
class KarcherMeanFactorSO4(NonlinearFactor):
    def __init__(self, keys: list[int]) -> None:
        ...
class KernelFunctionType:
    """
    Members:
    
      KernelFunctionTypeNONE
    
      KernelFunctionTypeHUBER
    
      KernelFunctionTypeTUKEY
    """
    KernelFunctionTypeHUBER: typing.ClassVar[KernelFunctionType]  # value = <KernelFunctionType.KernelFunctionTypeHUBER: 1>
    KernelFunctionTypeNONE: typing.ClassVar[KernelFunctionType]  # value = <KernelFunctionType.KernelFunctionTypeNONE: 0>
    KernelFunctionTypeTUKEY: typing.ClassVar[KernelFunctionType]  # value = <KernelFunctionType.KernelFunctionTypeTUKEY: 2>
    __members__: typing.ClassVar[dict[str, KernelFunctionType]]  # value = {'KernelFunctionTypeNONE': <KernelFunctionType.KernelFunctionTypeNONE: 0>, 'KernelFunctionTypeHUBER': <KernelFunctionType.KernelFunctionTypeHUBER: 1>, 'KernelFunctionTypeTUKEY': <KernelFunctionType.KernelFunctionTypeTUKEY: 2>}
    def __and__(self, other: typing.Any) -> typing.Any:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __invert__(self) -> typing.Any:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __or__(self, other: typing.Any) -> typing.Any:
        ...
    def __rand__(self, other: typing.Any) -> typing.Any:
        ...
    def __repr__(self) -> str:
        ...
    def __ror__(self, other: typing.Any) -> typing.Any:
        ...
    def __rxor__(self, other: typing.Any) -> typing.Any:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __xor__(self, other: typing.Any) -> typing.Any:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class KeyGroupMap:
    def __init__(self) -> None:
        ...
    def at(self, key: int) -> int:
        ...
    def clear(self) -> None:
        ...
    def empty(self) -> bool:
        ...
    def erase(self, key: int) -> int:
        ...
    def insert2(self, key: int, val: int) -> bool:
        ...
    def size(self) -> int:
        ...
class KeyList:
    def __contains__(self, key: int) -> bool:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: KeyList) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def back(self) -> int:
        ...
    def clear(self) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def empty(self) -> bool:
        ...
    def front(self) -> int:
        ...
    def pop_back(self) -> None:
        ...
    def pop_front(self) -> None:
        ...
    def push_back(self, key: int) -> None:
        ...
    def push_front(self, key: int) -> None:
        ...
    def remove(self, key: int) -> None:
        ...
    def serialize(self) -> str:
        ...
    def size(self) -> int:
        ...
    def sort(self) -> None:
        ...
class KeySet:
    def __contains__(self, key: int) -> bool:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, set: KeySet) -> None:
        ...
    @typing.overload
    def __init__(self, vector: list[int]) -> None:
        ...
    @typing.overload
    def __init__(self, list: KeyList) -> None:
        ...
    def __iter__(self) -> typing.Iterator:
        ...
    def __len__(self) -> int:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def clear(self) -> None:
        ...
    def count(self, key: int) -> int:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, other: KeySet) -> bool:
        ...
    def erase(self, key: int) -> int:
        ...
    def insert(self, key: int) -> None:
        ...
    def merge(self, other: KeySet) -> None:
        ...
    def print(self, s: str = '') -> None:
        ...
    def serialize(self) -> str:
        ...
    def size(self) -> int:
        ...
class LabeledSymbol:
    @typing.overload
    def __init__(self, full_key: int) -> None:
        ...
    @typing.overload
    def __init__(self, key: LabeledSymbol) -> None:
        ...
    @typing.overload
    def __init__(self, valType: int, label: int, j: int) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def chr(self) -> int:
        ...
    def index(self) -> int:
        ...
    def key(self) -> int:
        ...
    def label(self) -> int:
        ...
    def lower(self) -> LabeledSymbol:
        ...
    def newChr(self, c: int) -> LabeledSymbol:
        ...
    def newLabel(self, label: int) -> LabeledSymbol:
        ...
    def print(self, s: str = '') -> None:
        ...
    def upper(self) -> LabeledSymbol:
        ...
class LevenbergMarquardtOptimizer(NonlinearOptimizer):
    @typing.overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: ...) -> None:
        ...
    @typing.overload
    def __init__(self, graph: NonlinearFactorGraph, initialValues: ..., params: LevenbergMarquardtParams) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def lambda_(self) -> float:
        ...
    def print(self, s: str = '') -> None:
        ...
class LevenbergMarquardtParams(NonlinearOptimizerParams):
    @staticmethod
    def CeresDefaults() -> LevenbergMarquardtParams:
        ...
    @staticmethod
    def EnsureHasOrdering(params: LevenbergMarquardtParams, graph: NonlinearFactorGraph) -> LevenbergMarquardtParams:
        ...
    @staticmethod
    def LegacyDefaults() -> LevenbergMarquardtParams:
        ...
    @staticmethod
    def ReplaceOrdering(params: LevenbergMarquardtParams, ordering: Ordering) -> LevenbergMarquardtParams:
        ...
    def __init__(self) -> None:
        ...
    def getDiagonalDamping(self) -> bool:
        ...
    def getLogFile(self) -> str:
        ...
    def getUseFixedLambdaFactor(self) -> bool:
        ...
    def getVerbosityLM(self) -> str:
        ...
    def getlambdaFactor(self) -> float:
        ...
    def getlambdaInitial(self) -> float:
        ...
    def getlambdaLowerBound(self) -> float:
        ...
    def getlambdaUpperBound(self) -> float:
        ...
    def setDiagonalDamping(self, flag: bool) -> None:
        ...
    def setLogFile(self, s: str) -> None:
        ...
    def setUseFixedLambdaFactor(self, flag: bool) -> None:
        ...
    def setVerbosityLM(self, s: str) -> None:
        ...
    def setlambdaFactor(self, value: float) -> None:
        ...
    def setlambdaInitial(self, value: float) -> None:
        ...
    def setlambdaLowerBound(self, value: float) -> None:
        ...
    def setlambdaUpperBound(self, value: float) -> None:
        ...
class LinearContainerFactor(NonlinearFactor):
    @staticmethod
    @typing.overload
    def ConvertLinearGraph(linear_graph: GaussianFactorGraph, linearizationPoint: ...) -> NonlinearFactorGraph:
        ...
    @staticmethod
    @typing.overload
    def ConvertLinearGraph(linear_graph: GaussianFactorGraph) -> NonlinearFactorGraph:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, factor: GaussianFactor, linearizationPoint: ...) -> None:
        ...
    @typing.overload
    def __init__(self, factor: GaussianFactor) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def factor(self) -> GaussianFactor:
        ...
    def isJacobian(self) -> bool:
        ...
    def serialize(self) -> str:
        ...
    def toHessian(self) -> HessianFactor:
        ...
    def toJacobian(self) -> JacobianFactor:
        ...
class LinearizationMode:
    """
    Members:
    
      HESSIAN
    
      IMPLICIT_SCHUR
    
      JACOBIAN_Q
    
      JACOBIAN_SVD
    """
    HESSIAN: typing.ClassVar[LinearizationMode]  # value = <LinearizationMode.HESSIAN: 0>
    IMPLICIT_SCHUR: typing.ClassVar[LinearizationMode]  # value = <LinearizationMode.IMPLICIT_SCHUR: 1>
    JACOBIAN_Q: typing.ClassVar[LinearizationMode]  # value = <LinearizationMode.JACOBIAN_Q: 2>
    JACOBIAN_SVD: typing.ClassVar[LinearizationMode]  # value = <LinearizationMode.JACOBIAN_SVD: 3>
    __members__: typing.ClassVar[dict[str, LinearizationMode]]  # value = {'HESSIAN': <LinearizationMode.HESSIAN: 0>, 'IMPLICIT_SCHUR': <LinearizationMode.IMPLICIT_SCHUR: 1>, 'JACOBIAN_Q': <LinearizationMode.JACOBIAN_Q: 2>, 'JACOBIAN_SVD': <LinearizationMode.JACOBIAN_SVD: 3>}
    def __and__(self, other: typing.Any) -> typing.Any:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __invert__(self) -> typing.Any:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __or__(self, other: typing.Any) -> typing.Any:
        ...
    def __rand__(self, other: typing.Any) -> typing.Any:
        ...
    def __repr__(self) -> str:
        ...
    def __ror__(self, other: typing.Any) -> typing.Any:
        ...
    def __rxor__(self, other: typing.Any) -> typing.Any:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __xor__(self, other: typing.Any) -> typing.Any:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class MFAS:
    def __init__(self, relativeTranslations: list[...], projectionDirection: Unit3) -> None:
        ...
    def computeOrdering(self) -> list[int]:
        ...
    def computeOutlierWeights(self) -> dict[tuple[int, int], float]:
        ...
class ManifoldEvaluationFactorChebyshev1BasisPose2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose2, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose2, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev1BasisPose3(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose3, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose3, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev1BasisRot2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot2, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot2, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev1BasisRot3(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot3, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot3, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev2BasisPose2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose2, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose2, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev2BasisPose3(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose3, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose3, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev2BasisRot2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot2, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot2, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev2BasisRot3(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot3, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot3, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev2Pose2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose2, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose2, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev2Pose3(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose3, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose3, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev2Rot2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot2, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot2, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorChebyshev2Rot3(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot3, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot3, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorFourierBasisPose2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose2, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose2, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorFourierBasisPose3(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose3, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Pose3, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorFourierBasisRot2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot2, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot2, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class ManifoldEvaluationFactorFourierBasisRot3(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot3, model: noiseModel.Base, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: Rot3, model: noiseModel.Base, N: int, x: float, a: float, b: float) -> None:
        ...
class Marginals:
    @typing.overload
    def __init__(self, graph: NonlinearFactorGraph, solution: ...) -> None:
        ...
    @typing.overload
    def __init__(self, gfgraph: GaussianFactorGraph, solution: ...) -> None:
        ...
    @typing.overload
    def __init__(self, gfgraph: GaussianFactorGraph, solutionvec: VectorValues) -> None:
        ...
    def __repr__(self, s: str = 'Marginals: ', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def jointMarginalCovariance(self, variables: list[int]) -> ...:
        ...
    def jointMarginalInformation(self, variables: list[int]) -> ...:
        ...
    def marginalCovariance(self, variable: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def marginalInformation(self, variable: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def print(self, s: str = 'Marginals: ', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class MixtureFactor(HybridFactor):
    @typing.overload
    def __init__(self, keys: list[int], discreteKeys: DiscreteKeys, factors: ..., std: ..., normalized: bool = False) -> None:
        ...
    @typing.overload
    def __init__(self, keys: list[int], discreteKeys: DiscreteKeys, factors: list[NonlinearFactor], normalized: bool = False) -> None:
        ...
    def __repr__(self, s: str = 'MixtureFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def error(self, continuousValues: Values, discreteValues: DiscreteValues) -> float:
        ...
    def linearize(self, continuousValues: Values) -> GaussianMixtureFactor:
        ...
    def nonlinearFactorLogNormalizingConstant(self, factor: NonlinearFactor, values: Values) -> float:
        ...
    def print(self, s: str = 'MixtureFactor\n', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class NavState:
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, R: Rot3, t: numpy.ndarray[numpy.float64[3, 1]], v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def attitude(self) -> Rot3:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, expected: NavState, tol: float) -> bool:
        ...
    def localCoordinates(self, g: NavState) -> numpy.ndarray[numpy.float64[9, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def position(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def retract(self, x: numpy.ndarray[numpy.float64[m, 1]]) -> NavState:
        ...
    def serialize(self) -> str:
        ...
    def velocity(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class NoiseFormat:
    """
    Members:
    
      NoiseFormatG2O
    
      NoiseFormatTORO
    
      NoiseFormatGRAPH
    
      NoiseFormatCOV
    
      NoiseFormatAUTO
    """
    NoiseFormatAUTO: typing.ClassVar[NoiseFormat]  # value = <NoiseFormat.NoiseFormatAUTO: 4>
    NoiseFormatCOV: typing.ClassVar[NoiseFormat]  # value = <NoiseFormat.NoiseFormatCOV: 3>
    NoiseFormatG2O: typing.ClassVar[NoiseFormat]  # value = <NoiseFormat.NoiseFormatG2O: 0>
    NoiseFormatGRAPH: typing.ClassVar[NoiseFormat]  # value = <NoiseFormat.NoiseFormatGRAPH: 2>
    NoiseFormatTORO: typing.ClassVar[NoiseFormat]  # value = <NoiseFormat.NoiseFormatTORO: 1>
    __members__: typing.ClassVar[dict[str, NoiseFormat]]  # value = {'NoiseFormatG2O': <NoiseFormat.NoiseFormatG2O: 0>, 'NoiseFormatTORO': <NoiseFormat.NoiseFormatTORO: 1>, 'NoiseFormatGRAPH': <NoiseFormat.NoiseFormatGRAPH: 2>, 'NoiseFormatCOV': <NoiseFormat.NoiseFormatCOV: 3>, 'NoiseFormatAUTO': <NoiseFormat.NoiseFormatAUTO: 4>}
    def __and__(self, other: typing.Any) -> typing.Any:
        ...
    def __eq__(self, other: typing.Any) -> bool:
        ...
    def __ge__(self, other: typing.Any) -> bool:
        ...
    def __getstate__(self) -> int:
        ...
    def __gt__(self, other: typing.Any) -> bool:
        ...
    def __hash__(self) -> int:
        ...
    def __index__(self) -> int:
        ...
    def __init__(self, value: int) -> None:
        ...
    def __int__(self) -> int:
        ...
    def __invert__(self) -> typing.Any:
        ...
    def __le__(self, other: typing.Any) -> bool:
        ...
    def __lt__(self, other: typing.Any) -> bool:
        ...
    def __ne__(self, other: typing.Any) -> bool:
        ...
    def __or__(self, other: typing.Any) -> typing.Any:
        ...
    def __rand__(self, other: typing.Any) -> typing.Any:
        ...
    def __repr__(self) -> str:
        ...
    def __ror__(self, other: typing.Any) -> typing.Any:
        ...
    def __rxor__(self, other: typing.Any) -> typing.Any:
        ...
    def __setstate__(self, state: int) -> None:
        ...
    def __str__(self) -> str:
        ...
    def __xor__(self, other: typing.Any) -> typing.Any:
        ...
    @property
    def name(self) -> str:
        ...
    @property
    def value(self) -> int:
        ...
class NoiseModelFactor(NonlinearFactor):
    def equals(self, other: NoiseModelFactor, tol: float) -> bool:
        ...
    def noiseModel(self) -> noiseModel.Base:
        ...
    def unwhitenedError(self, x: ...) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def whitenedError(self, x: ...) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2Cal3_S2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: Cal3_S2, x2: Cal3_S2) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2CalibratedCamera(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: CalibratedCamera, x2: CalibratedCamera) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2ConstantBias(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: ..., x2: ...) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2PinholeCameraCal3Bundler(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: PinholeCameraCal3Bundler, x2: PinholeCameraCal3Bundler) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2PinholeCameraCal3Fisheye(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: PinholeCameraCal3Fisheye, x2: PinholeCameraCal3Fisheye) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2PinholeCameraCal3Unified(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: PinholeCameraCal3Unified, x2: PinholeCameraCal3Unified) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2PinholeCameraCal3_S2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: PinholeCameraCal3_S2, x2: PinholeCameraCal3_S2) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2Point2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: numpy.ndarray[numpy.float64[2, 1]], x2: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2Point3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: numpy.ndarray[numpy.float64[3, 1]], x2: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2Pose2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: Pose2, x2: Pose2) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2Pose3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: Pose3, x2: Pose3) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2Rot2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: Rot2, x2: Rot2) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2Rot3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: Rot3, x2: Rot3) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2SO3(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: SO3, x2: SO3) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2SO4(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: SO4, x2: SO4) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2SOn(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: SOn, x2: SOn) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEquality2StereoPoint2(NoiseModelFactor):
    def __init__(self, key1: int, key2: int, mu: float = 10000.0) -> None:
        ...
    def evaluateError(self, x1: StereoPoint2, x2: StereoPoint2) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class NonlinearEqualityCal3_S2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Cal3_S2) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Cal3_S2, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityCalibratedCamera(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: CalibratedCamera) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: CalibratedCamera, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityConstantBias(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: ...) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: ..., error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityPinholeCameraCal3Bundler(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: PinholeCameraCal3Bundler) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: PinholeCameraCal3Bundler, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityPinholeCameraCal3Fisheye(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: PinholeCameraCal3Fisheye) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: PinholeCameraCal3Fisheye, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityPinholeCameraCal3Unified(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: PinholeCameraCal3Unified) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: PinholeCameraCal3Unified, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityPinholeCameraCal3_S2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: PinholeCameraCal3_S2) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: PinholeCameraCal3_S2, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityPoint2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: numpy.ndarray[numpy.float64[2, 1]], error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityPoint3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: numpy.ndarray[numpy.float64[3, 1]], error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityPose2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Pose2) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Pose2, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityPose3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Pose3, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityRot2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Rot2) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Rot2, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityRot3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Rot3) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: Rot3, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualitySO3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: SO3) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: SO3, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualitySO4(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: SO4) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: SO4, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualitySOn(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: SOn) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: SOn, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearEqualityStereoPoint2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: StereoPoint2) -> None:
        ...
    @typing.overload
    def __init__(self, j: int, feasible: StereoPoint2, error_gain: float) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def serialize(self) -> str:
        ...
class NonlinearFactor(Factor):
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def active(self, c: ...) -> bool:
        ...
    def clone(self) -> NonlinearFactor:
        ...
    def dim(self) -> int:
        ...
    def equals(self, other: NonlinearFactor, tol: float) -> bool:
        ...
    def error(self, c: ...) -> float:
        ...
    def linearize(self, c: ...) -> GaussianFactor:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def rekey(self, newKeys: list[int]) -> NonlinearFactor:
        ...
class NonlinearFactorGraph:
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, graph: NonlinearFactorGraph) -> None:
        ...
    def __repr__(self, s: str = 'NonlinearFactorGraph: ', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def add(self, factor: ...) -> None:
        ...
    def addPriorCal3Fisheye(self, key: int, prior: Cal3Fisheye, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorCal3Unified(self, key: int, prior: Cal3Unified, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorCal3_S2(self, key: int, prior: Cal3_S2, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorCalibratedCamera(self, key: int, prior: CalibratedCamera, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorConstantBias(self, key: int, prior: ..., noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorDouble(self, key: int, prior: float, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorPinholeCameraCal3Bundler(self, key: int, prior: PinholeCameraCal3Bundler, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorPinholeCameraCal3Fisheye(self, key: int, prior: PinholeCameraCal3Fisheye, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorPinholeCameraCal3Unified(self, key: int, prior: PinholeCameraCal3Unified, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorPinholeCameraCal3_S2(self, key: int, prior: PinholeCameraCal3_S2, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorPoint2(self, key: int, prior: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorPoint3(self, key: int, prior: numpy.ndarray[numpy.float64[3, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorPose2(self, key: int, prior: Pose2, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorPose3(self, key: int, prior: Pose3, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorRot2(self, key: int, prior: Rot2, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorRot3(self, key: int, prior: Rot3, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorSO3(self, key: int, prior: SO3, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorSO4(self, key: int, prior: SO4, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorStereoPoint2(self, key: int, prior: StereoPoint2, noiseModel: noiseModel.Base) -> None:
        ...
    def addPriorVector(self, key: int, prior: numpy.ndarray[numpy.float64[m, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def at(self, idx: int) -> ...:
        ...
    def clone(self) -> NonlinearFactorGraph:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dot(self, values: ..., keyFormatter: typing.Callable[[int], str] = ..., writer: GraphvizFormatting = ...) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, fg: NonlinearFactorGraph, tol: float) -> bool:
        ...
    def error(self, values: ...) -> float:
        ...
    def exists(self, idx: int) -> bool:
        ...
    def keyVector(self) -> list[int]:
        ...
    def keys(self) -> ...:
        ...
    def linearize(self, values: ...) -> GaussianFactorGraph:
        ...
    def nrFactors(self) -> int:
        ...
    def orderingCOLAMD(self) -> Ordering:
        ...
    def print(self, s: str = 'NonlinearFactorGraph: ', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def printErrors(self, values: ..., str: str = 'NonlinearFactorGraph: ', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def probPrime(self, values: ...) -> float:
        ...
    @typing.overload
    def push_back(self, factors: NonlinearFactorGraph) -> None:
        ...
    @typing.overload
    def push_back(self, factor: ...) -> None:
        ...
    def remove(self, i: int) -> None:
        ...
    def replace(self, i: int, factors: ...) -> None:
        ...
    def resize(self, size: int) -> None:
        ...
    def saveGraph(self, s: str, values: ..., keyFormatter: typing.Callable[[int], str] = ..., writer: GraphvizFormatting = ...) -> None:
        ...
    def serialize(self) -> str:
        ...
    def size(self) -> int:
        ...
class NonlinearISAM:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, reorderInterval: int) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def bayesTree(self) -> GaussianISAM:
        ...
    def estimate(self) -> ...:
        ...
    def getFactorsUnsafe(self) -> NonlinearFactorGraph:
        ...
    def getLinearizationPoint(self) -> ...:
        ...
    def marginalCovariance(self, key: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def printStats(self) -> None:
        ...
    def reorderCounter(self) -> int:
        ...
    def reorderInterval(self) -> int:
        ...
    def reorder_relinearize(self) -> None:
        ...
    def saveGraph(self, s: str) -> None:
        ...
    def update(self, newFactors: NonlinearFactorGraph, initialValues: ...) -> None:
        ...
class NonlinearOptimizer:
    def error(self) -> float:
        ...
    def graph(self) -> NonlinearFactorGraph:
        ...
    def iterate(self) -> GaussianFactorGraph:
        ...
    def iterations(self) -> int:
        ...
    def optimize(self) -> ...:
        ...
    def optimizeSafely(self) -> ...:
        ...
    def values(self) -> ...:
        ...
class NonlinearOptimizerParams:
    iterationHook: typing.Callable[[int, float, float], None]
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def getAbsoluteErrorTol(self) -> float:
        ...
    def getErrorTol(self) -> float:
        ...
    def getLinearSolverType(self) -> str:
        ...
    def getMaxIterations(self) -> int:
        ...
    def getOrderingType(self) -> str:
        ...
    def getRelativeErrorTol(self) -> float:
        ...
    def getVerbosity(self) -> str:
        ...
    def isCholmod(self) -> bool:
        ...
    def isIterative(self) -> bool:
        ...
    def isMultifrontal(self) -> bool:
        ...
    def isSequential(self) -> bool:
        ...
    def print(self, s: str = '') -> None:
        ...
    def setAbsoluteErrorTol(self, value: float) -> None:
        ...
    def setErrorTol(self, value: float) -> None:
        ...
    def setIterativeParams(self, params: IterativeOptimizationParameters) -> None:
        ...
    def setLinearSolverType(self, solver: str) -> None:
        ...
    def setMaxIterations(self, value: int) -> None:
        ...
    def setOrdering(self, ordering: Ordering) -> None:
        ...
    def setOrderingType(self, ordering: str) -> None:
        ...
    def setRelativeErrorTol(self, value: float) -> None:
        ...
    def setVerbosity(self, s: str) -> None:
        ...
class Ordering:
    class OrderingType:
        """
        Members:
        
          COLAMD
        
          METIS
        
          NATURAL
        
          CUSTOM
        """
        COLAMD: typing.ClassVar[Ordering.OrderingType]  # value = <OrderingType.COLAMD: 0>
        CUSTOM: typing.ClassVar[Ordering.OrderingType]  # value = <OrderingType.CUSTOM: 3>
        METIS: typing.ClassVar[Ordering.OrderingType]  # value = <OrderingType.METIS: 1>
        NATURAL: typing.ClassVar[Ordering.OrderingType]  # value = <OrderingType.NATURAL: 2>
        __members__: typing.ClassVar[dict[str, Ordering.OrderingType]]  # value = {'COLAMD': <OrderingType.COLAMD: 0>, 'METIS': <OrderingType.METIS: 1>, 'NATURAL': <OrderingType.NATURAL: 2>, 'CUSTOM': <OrderingType.CUSTOM: 3>}
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    @staticmethod
    def Colamd(variableIndex: ...) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedFirstDiscreteFactorGraph(graph: ..., constrainFirst: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedFirstGaussianFactorGraph(graph: ..., constrainFirst: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedFirstHybridGaussianFactorGraph(graph: ..., constrainFirst: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedFirstNonlinearFactorGraph(graph: ..., constrainFirst: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedFirstSymbolicFactorGraph(graph: ..., constrainFirst: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedLastDiscreteFactorGraph(graph: ..., constrainLast: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedLastGaussianFactorGraph(graph: ..., constrainLast: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedLastHybridGaussianFactorGraph(graph: ..., constrainLast: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedLastNonlinearFactorGraph(graph: ..., constrainLast: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdConstrainedLastSymbolicFactorGraph(graph: ..., constrainLast: list[int], forceOrder: bool = False) -> Ordering:
        ...
    @staticmethod
    def ColamdDiscreteFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def ColamdGaussianFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def ColamdHybridGaussianFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def ColamdNonlinearFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def ColamdSymbolicFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def CreateDiscreteFactorGraph(orderingType: ..., graph: ...) -> Ordering:
        ...
    @staticmethod
    def CreateGaussianFactorGraph(orderingType: ..., graph: ...) -> Ordering:
        ...
    @staticmethod
    def CreateHybridGaussianFactorGraph(orderingType: ..., graph: ...) -> Ordering:
        ...
    @staticmethod
    def CreateNonlinearFactorGraph(orderingType: ..., graph: ...) -> Ordering:
        ...
    @staticmethod
    def CreateSymbolicFactorGraph(orderingType: ..., graph: ...) -> Ordering:
        ...
    @staticmethod
    def MetisDiscreteFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def MetisGaussianFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def MetisHybridGaussianFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def MetisNonlinearFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def MetisSymbolicFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def NaturalDiscreteFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def NaturalGaussianFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def NaturalHybridGaussianFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def NaturalNonlinearFactorGraph(graph: ...) -> Ordering:
        ...
    @staticmethod
    def NaturalSymbolicFactorGraph(graph: ...) -> Ordering:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: Ordering) -> None:
        ...
    @typing.overload
    def __init__(self, keys: list[int]) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def at(self, i: int) -> int:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, ord: Ordering, tol: float) -> bool:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def push_back(self, key: int) -> None:
        ...
    def serialize(self) -> str:
        ...
    def size(self) -> int:
        ...
class PCGSolverParameters(ConjugateGradientParameters):
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def print(self, s: str = '') -> None:
        ...
    def setPreconditionerParams(self, preconditioner: PreconditionerParameters) -> None:
        ...
class PinholeCameraCal3Bundler:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    @typing.overload
    def Level(K: Cal3Bundler, pose: Pose2, height: float) -> PinholeCameraCal3Bundler:
        ...
    @staticmethod
    @typing.overload
    def Level(pose: Pose2, height: float) -> PinholeCameraCal3Bundler:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3Bundler) -> PinholeCameraCal3Bundler:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholeCameraCal3Bundler) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3Bundler) -> None:
        ...
    def __repr__(self, s: str = 'PinholeCamera') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3Bundler:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholeCameraCal3Bundler, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholeCameraCal3Bundler) -> numpy.ndarray[numpy.float64[9, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholeCamera') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def reprojectionError(self, pw: numpy.ndarray[numpy.float64[3, 1]], measured: numpy.ndarray[numpy.float64[2, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholeCameraCal3Bundler:
        ...
    def serialize(self) -> str:
        ...
class PinholeCameraCal3DS2:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    @typing.overload
    def Level(K: Cal3DS2, pose: Pose2, height: float) -> PinholeCameraCal3DS2:
        ...
    @staticmethod
    @typing.overload
    def Level(pose: Pose2, height: float) -> PinholeCameraCal3DS2:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3DS2) -> PinholeCameraCal3DS2:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholeCameraCal3DS2) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3DS2) -> None:
        ...
    def __repr__(self, s: str = 'PinholeCamera') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3DS2:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholeCameraCal3DS2, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholeCameraCal3DS2) -> numpy.ndarray[numpy.float64[15, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholeCamera') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def reprojectionError(self, pw: numpy.ndarray[numpy.float64[3, 1]], measured: numpy.ndarray[numpy.float64[2, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholeCameraCal3DS2:
        ...
    def serialize(self) -> str:
        ...
class PinholeCameraCal3Fisheye:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    @typing.overload
    def Level(K: Cal3Fisheye, pose: Pose2, height: float) -> PinholeCameraCal3Fisheye:
        ...
    @staticmethod
    @typing.overload
    def Level(pose: Pose2, height: float) -> PinholeCameraCal3Fisheye:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3Fisheye) -> PinholeCameraCal3Fisheye:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholeCameraCal3Fisheye) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3Fisheye) -> None:
        ...
    def __repr__(self, s: str = 'PinholeCamera') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3Fisheye:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholeCameraCal3Fisheye, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholeCameraCal3Fisheye) -> numpy.ndarray[numpy.float64[15, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholeCamera') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def reprojectionError(self, pw: numpy.ndarray[numpy.float64[3, 1]], measured: numpy.ndarray[numpy.float64[2, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholeCameraCal3Fisheye:
        ...
    def serialize(self) -> str:
        ...
class PinholeCameraCal3Unified:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    @typing.overload
    def Level(K: Cal3Unified, pose: Pose2, height: float) -> PinholeCameraCal3Unified:
        ...
    @staticmethod
    @typing.overload
    def Level(pose: Pose2, height: float) -> PinholeCameraCal3Unified:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3Unified) -> PinholeCameraCal3Unified:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholeCameraCal3Unified) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3Unified) -> None:
        ...
    def __repr__(self, s: str = 'PinholeCamera') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3Unified:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholeCameraCal3Unified, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholeCameraCal3Unified) -> numpy.ndarray[numpy.float64[16, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholeCamera') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def reprojectionError(self, pw: numpy.ndarray[numpy.float64[3, 1]], measured: numpy.ndarray[numpy.float64[2, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholeCameraCal3Unified:
        ...
    def serialize(self) -> str:
        ...
class PinholeCameraCal3_S2:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    @typing.overload
    def Level(K: Cal3_S2, pose: Pose2, height: float) -> PinholeCameraCal3_S2:
        ...
    @staticmethod
    @typing.overload
    def Level(pose: Pose2, height: float) -> PinholeCameraCal3_S2:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3_S2) -> PinholeCameraCal3_S2:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholeCameraCal3_S2) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3_S2) -> None:
        ...
    def __repr__(self, s: str = 'PinholeCamera') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3_S2:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholeCameraCal3_S2, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholeCameraCal3_S2) -> numpy.ndarray[numpy.float64[11, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholeCamera') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def reprojectionError(self, pw: numpy.ndarray[numpy.float64[3, 1]], measured: numpy.ndarray[numpy.float64[2, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholeCameraCal3_S2:
        ...
    def serialize(self) -> str:
        ...
class PinholePoseCal3Bundler:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    def Level(pose: Pose2, height: float) -> PinholePoseCal3Bundler:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3Bundler) -> PinholePoseCal3Bundler:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholePoseCal3Bundler) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3Bundler) -> None:
        ...
    def __repr__(self, s: str = 'PinholePose') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3Bundler:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholePoseCal3Bundler, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholePoseCal3Bundler) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholePose') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholePoseCal3Bundler:
        ...
    def serialize(self) -> str:
        ...
class PinholePoseCal3DS2:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    def Level(pose: Pose2, height: float) -> PinholePoseCal3DS2:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3DS2) -> PinholePoseCal3DS2:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholePoseCal3DS2) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3DS2) -> None:
        ...
    def __repr__(self, s: str = 'PinholePose') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3DS2:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholePoseCal3DS2, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholePoseCal3DS2) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholePose') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholePoseCal3DS2:
        ...
    def serialize(self) -> str:
        ...
class PinholePoseCal3Fisheye:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    def Level(pose: Pose2, height: float) -> PinholePoseCal3Fisheye:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3Fisheye) -> PinholePoseCal3Fisheye:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholePoseCal3Fisheye) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3Fisheye) -> None:
        ...
    def __repr__(self, s: str = 'PinholePose') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3Fisheye:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholePoseCal3Fisheye, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholePoseCal3Fisheye) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholePose') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholePoseCal3Fisheye:
        ...
    def serialize(self) -> str:
        ...
class PinholePoseCal3Unified:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    def Level(pose: Pose2, height: float) -> PinholePoseCal3Unified:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3Unified) -> PinholePoseCal3Unified:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholePoseCal3Unified) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3Unified) -> None:
        ...
    def __repr__(self, s: str = 'PinholePose') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3Unified:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholePoseCal3Unified, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholePoseCal3Unified) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholePose') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholePoseCal3Unified:
        ...
    def serialize(self) -> str:
        ...
class PinholePoseCal3_S2:
    @staticmethod
    def Dim() -> int:
        ...
    @staticmethod
    def Level(pose: Pose2, height: float) -> PinholePoseCal3_S2:
        ...
    @staticmethod
    def Lookat(eye: numpy.ndarray[numpy.float64[3, 1]], target: numpy.ndarray[numpy.float64[3, 1]], upVector: numpy.ndarray[numpy.float64[3, 1]], K: Cal3_S2) -> PinholePoseCal3_S2:
        ...
    @staticmethod
    def Project(cameraPoint: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: PinholePoseCal3_S2) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3_S2) -> None:
        ...
    def __repr__(self, s: str = 'PinholePose') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def backproject(self, p: numpy.ndarray[numpy.float64[2, 1]], depth: float, Dresult_dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_ddepth: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dresult_dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def calibration(self) -> Cal3_S2:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: PinholePoseCal3_S2, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: PinholePoseCal3_S2) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = 'PinholePose') -> None:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dcal: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def projectSafe(self, pw: numpy.ndarray[numpy.float64[3, 1]]) -> tuple[numpy.ndarray[numpy.float64[2, 1]], bool]:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Dcamera: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Dpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> PinholePoseCal3_S2:
        ...
    def serialize(self) -> str:
        ...
class Pose2:
    @staticmethod
    @typing.overload
    def Align(abPointPairs: list[tuple[numpy.ndarray[numpy.float64[2, 1]], numpy.ndarray[numpy.float64[2, 1]]]]) -> Pose2 | None:
        ...
    @staticmethod
    @typing.overload
    def Align(a: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, n]]) -> Pose2 | None:
        ...
    @staticmethod
    def Expmap(v: numpy.ndarray[numpy.float64[m, 1]]) -> Pose2:
        ...
    @staticmethod
    def ExpmapDerivative(v: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def Identity() -> Pose2:
        ...
    @staticmethod
    def Logmap(p: Pose2) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @staticmethod
    def LogmapDerivative(v: Pose2) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def adjointMap_(v: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @staticmethod
    def adjointTranspose(xi: numpy.ndarray[numpy.float64[m, 1]], y: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @staticmethod
    def adjoint_(xi: numpy.ndarray[numpy.float64[m, 1]], y: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @staticmethod
    def wedge(vx: float, vy: float, w: float) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def Adjoint(self, xi: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def AdjointMap(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: Pose2) -> None:
        ...
    @typing.overload
    def __init__(self, x: float, y: float, theta: float) -> None:
        ...
    @typing.overload
    def __init__(self, theta: float, t: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, r: Rot2, t: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def __mul__(self, arg0: Pose2) -> Pose2:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def bearing(self, point: numpy.ndarray[numpy.float64[2, 1]]) -> Rot2:
        ...
    @typing.overload
    def between(self, p2: Pose2) -> Pose2:
        ...
    @typing.overload
    def between(self, p2: Pose2, H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose2:
        ...
    @typing.overload
    def compose(self, p2: Pose2) -> Pose2:
        ...
    @typing.overload
    def compose(self, p2: Pose2, H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose2:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, pose: Pose2, tol: float) -> bool:
        ...
    def inverse(self) -> Pose2:
        ...
    @typing.overload
    def localCoordinates(self, p: Pose2) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def localCoordinates(self, p: Pose2, H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def logmap(self, p: Pose2) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def logmap(self, p: Pose2, H: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def range(self, point: numpy.ndarray[numpy.float64[2, 1]]) -> float:
        ...
    @typing.overload
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Pose2:
        ...
    @typing.overload
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]], H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose2:
        ...
    @typing.overload
    def rotation(self) -> Rot2:
        ...
    @typing.overload
    def rotation(self, Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Rot2:
        ...
    def serialize(self) -> str:
        ...
    def theta(self) -> float:
        ...
    @typing.overload
    def transformFrom(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def transformFrom(self, points: numpy.ndarray[numpy.float64[m, n]]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def transformTo(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def transformTo(self, points: numpy.ndarray[numpy.float64[m, n]]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def translation(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def translation(self, Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def x(self) -> float:
        ...
    def y(self) -> float:
        ...
class Pose3:
    @staticmethod
    @typing.overload
    def Align(abPointPairs: list[tuple[numpy.ndarray[numpy.float64[3, 1]], numpy.ndarray[numpy.float64[3, 1]]]]) -> Pose3 | None:
        ...
    @staticmethod
    @typing.overload
    def Align(a: numpy.ndarray[numpy.float64[m, n]], b: numpy.ndarray[numpy.float64[m, n]]) -> Pose3 | None:
        ...
    @staticmethod
    @typing.overload
    def Expmap(v: numpy.ndarray[numpy.float64[m, 1]]) -> Pose3:
        ...
    @staticmethod
    @typing.overload
    def Expmap(v: numpy.ndarray[numpy.float64[m, 1]], Hxi: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose3:
        ...
    @staticmethod
    def ExpmapDerivative(xi: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    @staticmethod
    def Identity() -> Pose3:
        ...
    @staticmethod
    @typing.overload
    def Logmap(pose: Pose3) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @staticmethod
    @typing.overload
    def Logmap(pose: Pose3, Hpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @staticmethod
    def LogmapDerivative(xi: Pose3) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    @staticmethod
    def adjoint(xi: numpy.ndarray[numpy.float64[m, 1]], y: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @staticmethod
    def adjointMap(xi: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    @staticmethod
    def adjointMap_(xi: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    @staticmethod
    def adjointTranspose(xi: numpy.ndarray[numpy.float64[m, 1]], y: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @staticmethod
    def adjoint_(xi: numpy.ndarray[numpy.float64[m, 1]], y: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @staticmethod
    def wedge(wx: float, wy: float, wz: float, vx: float, vy: float, vz: float) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def Adjoint(self, xi: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def Adjoint(self, xi: numpy.ndarray[numpy.float64[m, 1]], H_this: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H_xib: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def AdjointMap(self) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    @typing.overload
    def AdjointTranspose(self, xi: numpy.ndarray[numpy.float64[m, 1]]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def AdjointTranspose(self, xi: numpy.ndarray[numpy.float64[m, 1]], H_this: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H_x: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, r: Rot3, t: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, pose2: Pose2) -> None:
        ...
    @typing.overload
    def __init__(self, mat: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def __mul__(self, arg0: Pose3) -> Pose3:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def between(self, pose: Pose3) -> Pose3:
        ...
    @typing.overload
    def between(self, pose: Pose3, H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose3:
        ...
    @typing.overload
    def compose(self, pose: Pose3) -> Pose3:
        ...
    @typing.overload
    def compose(self, pose: Pose3, H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose3:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, pose: Pose3, tol: float) -> bool:
        ...
    def expmap(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Pose3:
        ...
    @typing.overload
    def inverse(self) -> Pose3:
        ...
    @typing.overload
    def inverse(self, H: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose3:
        ...
    @typing.overload
    def localCoordinates(self, pose: Pose3) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    @typing.overload
    def localCoordinates(self, pose: Pose3, Hxi: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def logmap(self, pose: Pose3) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[4, 4]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> float:
        ...
    @typing.overload
    def range(self, point: numpy.ndarray[numpy.float64[3, 1]], Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Hpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3) -> float:
        ...
    @typing.overload
    def range(self, pose: Pose3, Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Hpose: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Pose3:
        ...
    @typing.overload
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]], Hxi: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose3:
        ...
    @typing.overload
    def rotation(self) -> Rot3:
        ...
    @typing.overload
    def rotation(self, Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Rot3:
        ...
    def serialize(self) -> str:
        ...
    @typing.overload
    def slerp(self, t: float, pose: Pose3) -> Pose3:
        ...
    @typing.overload
    def slerp(self, t: float, pose: Pose3, Hx: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Hy: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose3:
        ...
    @typing.overload
    def transformFrom(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def transformFrom(self, point: numpy.ndarray[numpy.float64[3, 1]], Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Hpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def transformFrom(self, points: numpy.ndarray[numpy.float64[m, n]]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def transformPoseFrom(self, pose: Pose3) -> Pose3:
        ...
    @typing.overload
    def transformPoseFrom(self, pose: Pose3, Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], HaTb: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose3:
        ...
    @typing.overload
    def transformPoseTo(self, pose: Pose3) -> Pose3:
        ...
    @typing.overload
    def transformPoseTo(self, pose: Pose3, Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], HwTb: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Pose3:
        ...
    @typing.overload
    def transformTo(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def transformTo(self, point: numpy.ndarray[numpy.float64[3, 1]], Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Hpoint: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def transformTo(self, points: numpy.ndarray[numpy.float64[m, n]]) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    @typing.overload
    def translation(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def translation(self, Hself: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def x(self) -> float:
        ...
    def y(self) -> float:
        ...
    def z(self) -> float:
        ...
class Pose3AttitudeFactor(NonlinearFactor):
    @typing.overload
    def __init__(self, key: int, nZ: Unit3, model: noiseModel.Diagonal, bRef: Unit3) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, nZ: Unit3, model: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def bRef(self) -> Unit3:
        ...
    def equals(self, expected: NonlinearFactor, tol: float) -> bool:
        ...
    def nZ(self) -> Unit3:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class PoseRotationPrior2D(NoiseModelFactor):
    def __init__(self, key: int, pose_z: Pose2, noiseModel: noiseModel.Base) -> None:
        ...
    def measured(self) -> Rot2:
        ...
class PoseRotationPrior3D(NoiseModelFactor):
    def __init__(self, key: int, pose_z: Pose3, noiseModel: noiseModel.Base) -> None:
        ...
    def measured(self) -> Rot3:
        ...
class PoseTranslationPrior2D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, pose_z: Pose2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
class PoseTranslationPrior3D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, pose_z: Pose3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def serialize(self) -> str:
        ...
class PreconditionerParameters:
    def __init__(self) -> None:
        ...
class PreintegratedAhrsMeasurements:
    @typing.overload
    def __init__(self, params: PreintegrationParams, biasHat: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, p: PreintegrationParams, bias_hat: numpy.ndarray[numpy.float64[m, 1]], deltaTij: float, deltaRij: Rot3, delRdelBiasOmega: numpy.ndarray[numpy.float64[m, n]], preint_meas_cov: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def __init__(self, rhs: PreintegratedAhrsMeasurements) -> None:
        ...
    def __repr__(self, s: str = 'Preintegrated Measurements: ') -> str:
        ...
    def biasHat(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def deltaRij(self) -> Rot3:
        ...
    def deltaTij(self) -> float:
        ...
    def equals(self, expected: PreintegratedAhrsMeasurements, tol: float) -> bool:
        ...
    def integrateMeasurement(self, measuredOmega: numpy.ndarray[numpy.float64[m, 1]], deltaT: float) -> None:
        ...
    def print(self, s: str = 'Preintegrated Measurements: ') -> None:
        ...
    def resetIntegration(self) -> None:
        ...
class PreintegratedCombinedMeasurements:
    @typing.overload
    def __init__(self, params: PreintegrationCombinedParams) -> None:
        ...
    @typing.overload
    def __init__(self, params: PreintegrationCombinedParams, bias: imuBias.ConstantBias) -> None:
        ...
    def __repr__(self, s: str = 'Preintegrated Measurements:') -> str:
        ...
    def biasHat(self) -> imuBias.ConstantBias:
        ...
    def biasHatVector(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def deltaPij(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def deltaRij(self) -> Rot3:
        ...
    def deltaTij(self) -> float:
        ...
    def deltaVij(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def equals(self, expected: PreintegratedCombinedMeasurements, tol: float) -> bool:
        ...
    def integrateMeasurement(self, measuredAcc: numpy.ndarray[numpy.float64[m, 1]], measuredOmega: numpy.ndarray[numpy.float64[m, 1]], deltaT: float) -> None:
        ...
    def predict(self, state_i: NavState, bias: imuBias.ConstantBias) -> NavState:
        ...
    def preintMeasCov(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def print(self, s: str = 'Preintegrated Measurements:') -> None:
        ...
    def resetIntegration(self) -> None:
        ...
    def resetIntegrationAndSetBias(self, biasHat: imuBias.ConstantBias) -> None:
        ...
class PreintegratedImuMeasurements:
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, params: PreintegrationParams) -> None:
        ...
    @typing.overload
    def __init__(self, params: PreintegrationParams, bias: imuBias.ConstantBias) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def biasHat(self) -> imuBias.ConstantBias:
        ...
    def biasHatVector(self) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def deltaPij(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def deltaRij(self) -> Rot3:
        ...
    def deltaTij(self) -> float:
        ...
    def deltaVij(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, expected: PreintegratedImuMeasurements, tol: float) -> bool:
        ...
    def integrateMeasurement(self, measuredAcc: numpy.ndarray[numpy.float64[m, 1]], measuredOmega: numpy.ndarray[numpy.float64[m, 1]], deltaT: float) -> None:
        ...
    def predict(self, state_i: NavState, bias: imuBias.ConstantBias) -> NavState:
        ...
    def preintMeasCov(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def preintegrated(self) -> numpy.ndarray[numpy.float64[9, 1]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def resetIntegration(self) -> None:
        ...
    def resetIntegrationAndSetBias(self, biasHat: imuBias.ConstantBias) -> None:
        ...
    def serialize(self) -> str:
        ...
class PreintegratedRotationParams:
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def equals(self, expected: PreintegratedRotationParams, tol: float) -> bool:
        ...
    def getBodyPSensor(self) -> Pose3 | None:
        ...
    def getGyroscopeCovariance(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getOmegaCoriolis(self) -> numpy.ndarray[numpy.float64[3, 1]] | None:
        ...
    def print(self, s: str = '') -> None:
        ...
    def setBodyPSensor(self, pose: Pose3) -> None:
        ...
    def setGyroscopeCovariance(self, cov: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def setOmegaCoriolis(self, omega: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
class PreintegrationCombinedParams(PreintegrationParams):
    @staticmethod
    @typing.overload
    def MakeSharedD(g: float) -> PreintegrationCombinedParams:
        ...
    @staticmethod
    @typing.overload
    def MakeSharedD() -> PreintegrationCombinedParams:
        ...
    @staticmethod
    @typing.overload
    def MakeSharedU(g: float) -> PreintegrationCombinedParams:
        ...
    @staticmethod
    @typing.overload
    def MakeSharedU() -> PreintegrationCombinedParams:
        ...
    def __init__(self, n_gravity: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def equals(self, expected: PreintegrationCombinedParams, tol: float) -> bool:
        ...
    def getBiasAccCovariance(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getBiasAccOmegaInit(self) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    def getBiasOmegaCovariance(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def setBiasAccCovariance(self, cov: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def setBiasAccOmegaInit(self, cov: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def setBiasOmegaCovariance(self, cov: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
class PreintegrationParams(PreintegratedRotationParams):
    n_gravity: numpy.ndarray[numpy.float64[3, 1]]
    @staticmethod
    @typing.overload
    def MakeSharedD(g: float) -> PreintegrationParams:
        ...
    @staticmethod
    @typing.overload
    def MakeSharedD() -> PreintegrationParams:
        ...
    @staticmethod
    @typing.overload
    def MakeSharedU(g: float) -> PreintegrationParams:
        ...
    @staticmethod
    @typing.overload
    def MakeSharedU() -> PreintegrationParams:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, n_gravity: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, expected: PreintegrationParams, tol: float) -> bool:
        ...
    def getAccelerometerCovariance(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getIntegrationCovariance(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def getUse2ndOrderCoriolis(self) -> bool:
        ...
    def print(self, s: str = '') -> None:
        ...
    def serialize(self) -> str:
        ...
    def setAccelerometerCovariance(self, cov: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def setIntegrationCovariance(self, cov: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def setUse2ndOrderCoriolis(self, flag: bool) -> None:
        ...
class PriorFactorCal3Bundler(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Cal3Bundler, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Cal3Bundler:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorCal3DS2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Cal3DS2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Cal3DS2:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorCal3Fisheye(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Cal3Fisheye, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Cal3Fisheye:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorCal3Unified(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Cal3Unified, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Cal3Unified:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorCal3_S2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Cal3_S2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Cal3_S2:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorCalibratedCamera(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: CalibratedCamera, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> CalibratedCamera:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorConstantBias(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: ..., noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> ...:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorDouble(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorPinholeCameraCal3Bundler(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: PinholeCameraCal3Bundler, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> PinholeCameraCal3Bundler:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorPinholeCameraCal3Fisheye(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: PinholeCameraCal3Fisheye, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> PinholeCameraCal3Fisheye:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorPinholeCameraCal3Unified(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: PinholeCameraCal3Unified, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> PinholeCameraCal3Unified:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorPinholeCameraCal3_S2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: PinholeCameraCal3_S2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> PinholeCameraCal3_S2:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorPoint2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: numpy.ndarray[numpy.float64[2, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorPoint3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: numpy.ndarray[numpy.float64[3, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorPose2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Pose2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Pose2:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorPose3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Pose3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Pose3:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorRot2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Rot2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Rot2:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorRot3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Rot3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Rot3:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorSO3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: SO3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> SO3:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorSO4(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: SO4, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> SO4:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorSOn(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: SOn, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> SOn:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorStereoPoint2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: StereoPoint2, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> StereoPoint2:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorUnit3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: Unit3, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> Unit3:
        ...
    def serialize(self) -> str:
        ...
class PriorFactorVector(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key: int, prior: numpy.ndarray[numpy.float64[m, 1]], noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def prior(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def serialize(self) -> str:
        ...
class Quaternion:
    def coeffs(self) -> numpy.ndarray[numpy.float64[4, 1]]:
        ...
    def w(self) -> float:
        ...
    def x(self) -> float:
        ...
    def y(self) -> float:
        ...
    def z(self) -> float:
        ...
class RangeFactor2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactor2D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactor3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactor3D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorCalibratedCamera(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorCalibratedCameraPoint(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorPose2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorPose3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorSimpleCamera(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorSimpleCameraPoint(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorWithTransform2D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base, body_T_sensor: Pose2) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorWithTransform3D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base, body_T_sensor: Pose3) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorWithTransformBias2D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, key3: int, measured: float, noiseModel: noiseModel.Base, body_T_sensor: Pose2) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorWithTransformBias3D(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, key3: int, measured: float, noiseModel: noiseModel.Base, body_T_sensor: Pose3) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorWithTransformPose2(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base, body_T_sensor: Pose2) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RangeFactorWithTransformPose3(NoiseModelFactor):
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, key1: int, key2: int, measured: float, noiseModel: noiseModel.Base, body_T_sensor: Pose3) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def measured(self) -> float:
        ...
    def serialize(self) -> str:
        ...
class RedirectCout:
    def __init__(self) -> None:
        ...
    def str(self) -> str:
        ...
class Rot2:
    @staticmethod
    def Expmap(v: numpy.ndarray[numpy.float64[m, 1]]) -> Rot2:
        ...
    @staticmethod
    def Identity() -> Rot2:
        ...
    @staticmethod
    def Logmap(p: Rot2) -> numpy.ndarray[numpy.float64[1, 1]]:
        ...
    @staticmethod
    def atan2(y: float, x: float) -> Rot2:
        ...
    @staticmethod
    def fromAngle(theta: float) -> Rot2:
        ...
    @staticmethod
    def fromCosSin(c: float, s: float) -> Rot2:
        ...
    @staticmethod
    def fromDegrees(theta: float) -> Rot2:
        ...
    @staticmethod
    def relativeBearing(d: numpy.ndarray[numpy.float64[2, 1]]) -> Rot2:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, theta: float) -> None:
        ...
    def __mul__(self, arg0: Rot2) -> Rot2:
        ...
    def __repr__(self, s: str = 'theta') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def between(self, p2: Rot2) -> Rot2:
        ...
    def c(self) -> float:
        ...
    def compose(self, p2: Rot2) -> Rot2:
        ...
    def degrees(self) -> float:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, rot: Rot2, tol: float) -> bool:
        ...
    def inverse(self) -> Rot2:
        ...
    @typing.overload
    def localCoordinates(self, p: Rot2) -> numpy.ndarray[numpy.float64[1, 1]]:
        ...
    @typing.overload
    def localCoordinates(self, p: Rot2, H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[1, 1]]:
        ...
    def logmap(self, p: Rot2) -> numpy.ndarray[numpy.float64[1, 1]]:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[2, 2]]:
        ...
    def print(self, s: str = 'theta') -> None:
        ...
    @typing.overload
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Rot2:
        ...
    @typing.overload
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]], H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Rot2:
        ...
    def rotate(self, point: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def s(self) -> float:
        ...
    def serialize(self) -> str:
        ...
    def theta(self) -> float:
        ...
    def unrotate(self, point: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class Rot3:
    @staticmethod
    def AxisAngle(axis: numpy.ndarray[numpy.float64[3, 1]], angle: float) -> Rot3:
        ...
    @staticmethod
    def ClosestTo(M: numpy.ndarray[numpy.float64[m, n]]) -> Rot3:
        ...
    @staticmethod
    def Expmap(v: numpy.ndarray[numpy.float64[m, 1]]) -> Rot3:
        ...
    @staticmethod
    def Identity() -> Rot3:
        ...
    @staticmethod
    def Logmap(p: Rot3) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @staticmethod
    def Pitch(t: float) -> Rot3:
        ...
    @staticmethod
    def Quaternion(w: float, x: float, y: float, z: float) -> Rot3:
        ...
    @staticmethod
    @typing.overload
    def Rodrigues(v: numpy.ndarray[numpy.float64[m, 1]]) -> Rot3:
        ...
    @staticmethod
    @typing.overload
    def Rodrigues(wx: float, wy: float, wz: float) -> Rot3:
        ...
    @staticmethod
    def Roll(t: float) -> Rot3:
        ...
    @staticmethod
    def Rx(t: float) -> Rot3:
        ...
    @staticmethod
    def Ry(t: float) -> Rot3:
        ...
    @staticmethod
    def Rz(t: float) -> Rot3:
        ...
    @staticmethod
    @typing.overload
    def RzRyRx(x: float, y: float, z: float) -> Rot3:
        ...
    @staticmethod
    @typing.overload
    def RzRyRx(xyz: numpy.ndarray[numpy.float64[m, 1]]) -> Rot3:
        ...
    @staticmethod
    def Yaw(t: float) -> Rot3:
        ...
    @staticmethod
    def Ypr(y: float, p: float, r: float) -> Rot3:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, R: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def __init__(self, col1: numpy.ndarray[numpy.float64[3, 1]], col2: numpy.ndarray[numpy.float64[3, 1]], col3: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def __init__(self, R11: float, R12: float, R13: float, R21: float, R22: float, R23: float, R31: float, R32: float, R33: float) -> None:
        ...
    @typing.overload
    def __init__(self, w: float, x: float, y: float, z: float) -> None:
        ...
    def __mul__(self, arg0: Rot3) -> Rot3:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def axisAngle(self) -> tuple[..., float]:
        ...
    def between(self, p2: Rot3) -> Rot3:
        ...
    def column(self, index: int) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def compose(self, p2: Rot3) -> Rot3:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, rot: Rot3, tol: float) -> bool:
        ...
    def inverse(self) -> Rot3:
        ...
    def localCoordinates(self, p: Rot3) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def logmap(self, p: Rot3) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def pitch(self) -> float:
        ...
    def print(self, s: str = '') -> None:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Rot3:
        ...
    def roll(self) -> float:
        ...
    @typing.overload
    def rotate(self, p: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def rotate(self, p: ...) -> ...:
        ...
    @typing.overload
    def rotate(self, p: ..., HR: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], Hp: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> ...:
        ...
    def rpy(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def serialize(self) -> str:
        ...
    def slerp(self, t: float, other: Rot3) -> Rot3:
        ...
    def toQuaternion(self) -> Quaternion:
        ...
    def transpose(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @typing.overload
    def unrotate(self, p: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def unrotate(self, p: ...) -> ...:
        ...
    def xyz(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def yaw(self) -> float:
        ...
    def ypr(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class Rot3AttitudeFactor(NonlinearFactor):
    @typing.overload
    def __init__(self, key: int, nZ: Unit3, model: noiseModel.Diagonal, bRef: Unit3) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, nZ: Unit3, model: noiseModel.Diagonal) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def bRef(self) -> Unit3:
        ...
    def equals(self, expected: NonlinearFactor, tol: float) -> bool:
        ...
    def nZ(self) -> Unit3:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class SO3:
    @staticmethod
    def AxisAngle(axis: numpy.ndarray[numpy.float64[m, 1]], theta: float) -> SO3:
        ...
    @staticmethod
    def ClosestTo(M: numpy.ndarray[numpy.float64[m, n]]) -> SO3:
        ...
    @staticmethod
    def Expmap(v: numpy.ndarray[numpy.float64[m, 1]]) -> SO3:
        ...
    @staticmethod
    def FromMatrix(R: numpy.ndarray[numpy.float64[m, n]]) -> SO3:
        ...
    @staticmethod
    def Identity() -> SO3:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, R: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def __mul__(self, arg0: SO3) -> SO3:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def between(self, R: SO3) -> SO3:
        ...
    def compose(self, R: SO3) -> SO3:
        ...
    def equals(self, other: SO3, tol: float) -> bool:
        ...
    def inverse(self) -> SO3:
        ...
    def localCoordinates(self, R: SO3) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> SO3:
        ...
    def vec(self) -> numpy.ndarray[numpy.float64[9, 1]]:
        ...
class SO4:
    @staticmethod
    def Expmap(v: numpy.ndarray[numpy.float64[m, 1]]) -> SO4:
        ...
    @staticmethod
    def FromMatrix(R: numpy.ndarray[numpy.float64[m, n]]) -> SO4:
        ...
    @staticmethod
    def Identity() -> SO4:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, R: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def __mul__(self, arg0: SO4) -> SO4:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def between(self, Q: SO4) -> SO4:
        ...
    def compose(self, Q: SO4) -> SO4:
        ...
    def equals(self, other: SO4, tol: float) -> bool:
        ...
    def inverse(self) -> SO4:
        ...
    def localCoordinates(self, Q: SO4) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[4, 4]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> SO4:
        ...
    def vec(self) -> numpy.ndarray[numpy.float64[16, 1]]:
        ...
class SOn:
    @staticmethod
    def Expmap(v: numpy.ndarray[numpy.float64[m, 1]]) -> SOn:
        ...
    @staticmethod
    def FromMatrix(R: numpy.ndarray[numpy.float64[m, n]]) -> SOn:
        ...
    @staticmethod
    def Identity() -> SOn:
        ...
    @staticmethod
    def Lift(n: int, R: numpy.ndarray[numpy.float64[m, n]]) -> SOn:
        ...
    def __getstate__(self) -> tuple:
        ...
    def __init__(self, n: int) -> None:
        ...
    def __mul__(self, arg0: SOn) -> SOn:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def between(self, Q: SOn) -> SOn:
        ...
    def compose(self, Q: SOn) -> SOn:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, other: SOn, tol: float) -> bool:
        ...
    def inverse(self) -> SOn:
        ...
    def localCoordinates(self, Q: SOn) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> SOn:
        ...
    def serialize(self) -> str:
        ...
    def vec(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class Sampler:
    @typing.overload
    def __init__(self, model: noiseModel.Diagonal, seed: int) -> None:
        ...
    @typing.overload
    def __init__(self, sigmas: numpy.ndarray[numpy.float64[m, 1]], seed: int) -> None:
        ...
    def dim(self) -> int:
        ...
    def model(self) -> noiseModel.Diagonal:
        ...
    def sample(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def sigmas(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class Scenario:
    def acceleration_b(self, t: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def acceleration_n(self, t: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def navState(self, t: float) -> NavState:
        ...
    def omega_b(self, t: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def pose(self, t: float) -> Pose3:
        ...
    def rotation(self, t: float) -> Rot3:
        ...
    def velocity_b(self, t: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def velocity_n(self, t: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class ScenarioRunner:
    def __init__(self, scenario: Scenario, p: PreintegrationParams, imuSampleTime: float, bias: imuBias.ConstantBias) -> None:
        ...
    def actualAngularVelocity(self, t: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def actualSpecificForce(self, t: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def estimateCovariance(self, T: float, N: int, estimatedBias: imuBias.ConstantBias) -> numpy.ndarray[numpy.float64[9, 9]]:
        ...
    def estimateNoiseCovariance(self, N: int) -> numpy.ndarray[numpy.float64[6, 6]]:
        ...
    def gravity_n(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def imuSampleTime(self) -> float:
        ...
    def integrate(self, T: float, estimatedBias: imuBias.ConstantBias, corrupted: bool) -> PreintegratedImuMeasurements:
        ...
    def measuredAngularVelocity(self, t: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def measuredSpecificForce(self, t: float) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def predict(self, pim: PreintegratedImuMeasurements, estimatedBias: imuBias.ConstantBias) -> NavState:
        ...
class SfmData:
    @staticmethod
    def FromBalFile(filename: str) -> SfmData:
        ...
    @staticmethod
    def FromBundlerFile(filename: str) -> SfmData:
        ...
    @staticmethod
    def generalSfmFactors(*args, **kwargs):
        """
        ) -> gtsam.gtsam.NonlinearFactorGraph
        """
    @staticmethod
    def sfmFactorGraph(*args, **kwargs):
        """
        , fixedCamera: int = 0, fixedPoint: int = 0) -> gtsam.gtsam.NonlinearFactorGraph
        """
    def __getstate__(self) -> tuple:
        ...
    def __init__(self) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def addCamera(self, cam: PinholeCameraCal3Bundler) -> None:
        ...
    def addTrack(self, t: SfmTrack) -> None:
        ...
    def camera(self, idx: int) -> PinholeCameraCal3Bundler:
        ...
    def cameraList(self) -> list[PinholeCameraCal3Bundler]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, expected: SfmData, tol: float) -> bool:
        ...
    def numberCameras(self) -> int:
        ...
    def numberTracks(self) -> int:
        ...
    def serialize(self) -> str:
        ...
    def track(self, idx: int) -> SfmTrack:
        ...
    def trackList(self) -> list[SfmTrack]:
        ...
class SfmTrack(SfmTrack2d):
    b: float
    g: float
    p: numpy.ndarray[numpy.float64[3, 1]]
    r: float
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, pt: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, expected: SfmTrack, tol: float) -> bool:
        ...
    def point3(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def serialize(self) -> str:
        ...
class SfmTrack2d:
    measurements: list[tuple[int, numpy.ndarray[numpy.float64[2, 1]]]]
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, measurements: list[tuple[int, numpy.ndarray[numpy.float64[2, 1]]]]) -> None:
        ...
    def addMeasurement(self, idx: int, m: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    def hasUniqueCameras(self) -> bool:
        ...
    def indexVector(self) -> numpy.ndarray[numpy.int32[m, 1]]:
        ...
    def measurement(self, idx: int) -> tuple[int, numpy.ndarray[numpy.float64[2, 1]]]:
        ...
    def measurementMatrix(self) -> numpy.ndarray[numpy.float64[m, 2]]:
        ...
    def numberMeasurements(self) -> int:
        ...
    def siftIndex(self, idx: int) -> tuple[int, int]:
        ...
class ShonanAveraging2:
    @typing.overload
    def __init__(self, g2oFile: str) -> None:
        ...
    @typing.overload
    def __init__(self, g2oFile: str, parameters: ShonanAveragingParameters2) -> None:
        ...
    @typing.overload
    def __init__(self, factors: list[BetweenFactorPose2], parameters: ShonanAveragingParameters2) -> None:
        ...
    def buildGraphAt(self, p: int) -> NonlinearFactorGraph:
        ...
    def checkOptimality(self, values: Values) -> bool:
        ...
    def computeA_(self, values: Values) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def computeLambda_(self, values: Values) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def computeMinEigenValue(self, values: Values) -> float:
        ...
    def computeMinEigenVector(self, values: Values) -> tuple[float, numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    def cost(self, values: Values) -> float:
        ...
    def costAt(self, p: int, values: Values) -> float:
        ...
    def createOptimizerAt(self, p: int, initial: Values) -> LevenbergMarquardtOptimizer:
        ...
    def denseD(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def denseL(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def denseQ(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def initializeRandomly(self) -> Values:
        ...
    def initializeRandomlyAt(self, p: int) -> Values:
        ...
    def initializeWithDescent(self, p: int, values: Values, minEigenVector: numpy.ndarray[numpy.float64[m, 1]], minEigenValue: float) -> Values:
        ...
    def keys(self, i: int) -> list[int]:
        ...
    def measured(self, i: int) -> Rot2:
        ...
    def nrUnknowns(self) -> int:
        ...
    def numberMeasurements(self) -> int:
        ...
    def projectFrom(self, p: int, values: Values) -> Values:
        ...
    def roundSolution(self, values: Values) -> Values:
        ...
    def run(self, initial: Values, min_p: int, max_p: int) -> tuple[Values, float]:
        ...
    def tryOptimizingAt(self, p: int, initial: Values) -> Values:
        ...
class ShonanAveraging3:
    @typing.overload
    def __init__(self, measurements: list[...], parameters: ShonanAveragingParameters3 = ...) -> None:
        ...
    @typing.overload
    def __init__(self, g2oFile: str) -> None:
        ...
    @typing.overload
    def __init__(self, g2oFile: str, parameters: ShonanAveragingParameters3) -> None:
        ...
    @typing.overload
    def __init__(self, factors: list[BetweenFactorPose3], parameters: ShonanAveragingParameters3 = ...) -> None:
        ...
    def buildGraphAt(self, p: int) -> NonlinearFactorGraph:
        ...
    def checkOptimality(self, values: Values) -> bool:
        ...
    def computeA_(self, values: Values) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def computeLambda_(self, values: Values) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def computeMinEigenValue(self, values: Values) -> float:
        ...
    def computeMinEigenVector(self, values: Values) -> tuple[float, numpy.ndarray[numpy.float64[m, 1]]]:
        ...
    def cost(self, values: Values) -> float:
        ...
    def costAt(self, p: int, values: Values) -> float:
        ...
    def createOptimizerAt(self, p: int, initial: Values) -> LevenbergMarquardtOptimizer:
        ...
    def denseD(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def denseL(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def denseQ(self) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def initializeRandomly(self) -> Values:
        ...
    def initializeRandomlyAt(self, p: int) -> Values:
        ...
    def initializeWithDescent(self, p: int, values: Values, minEigenVector: numpy.ndarray[numpy.float64[m, 1]], minEigenValue: float) -> Values:
        ...
    def keys(self, i: int) -> list[int]:
        ...
    def measured(self, i: int) -> Rot3:
        ...
    def nrUnknowns(self) -> int:
        ...
    def numberMeasurements(self) -> int:
        ...
    def projectFrom(self, p: int, values: Values) -> Values:
        ...
    def roundSolution(self, values: Values) -> Values:
        ...
    def run(self, initial: Values, min_p: int, max_p: int) -> tuple[Values, float]:
        ...
    def tryOptimizingAt(self, p: int, initial: Values) -> Values:
        ...
class ShonanAveragingParameters2:
    @typing.overload
    def __init__(self, lm: LevenbergMarquardtParams) -> None:
        ...
    @typing.overload
    def __init__(self, lm: LevenbergMarquardtParams, method: str) -> None:
        ...
    def getAnchor(self) -> tuple[int, Rot2]:
        ...
    def getAnchorWeight(self) -> float:
        ...
    def getCertifyOptimality(self) -> bool:
        ...
    def getGaugesWeight(self) -> float:
        ...
    def getKarcherWeight(self) -> float:
        ...
    def getLMParams(self) -> LevenbergMarquardtParams:
        ...
    def getOptimalityThreshold(self) -> float:
        ...
    def getUseHuber(self) -> bool:
        ...
    def setAnchor(self, index: int, value: Rot2) -> None:
        ...
    def setAnchorWeight(self, value: float) -> None:
        ...
    def setCertifyOptimality(self, value: bool) -> None:
        ...
    def setGaugesWeight(self, value: float) -> None:
        ...
    def setKarcherWeight(self, value: float) -> None:
        ...
    def setOptimalityThreshold(self, value: float) -> None:
        ...
    def setUseHuber(self, value: bool) -> None:
        ...
class ShonanAveragingParameters3:
    @typing.overload
    def __init__(self, lm: LevenbergMarquardtParams) -> None:
        ...
    @typing.overload
    def __init__(self, lm: LevenbergMarquardtParams, method: str) -> None:
        ...
    def getAnchor(self) -> tuple[int, Rot3]:
        ...
    def getAnchorWeight(self) -> float:
        ...
    def getCertifyOptimality(self) -> bool:
        ...
    def getGaugesWeight(self) -> float:
        ...
    def getKarcherWeight(self) -> float:
        ...
    def getLMParams(self) -> LevenbergMarquardtParams:
        ...
    def getOptimalityThreshold(self) -> float:
        ...
    def getUseHuber(self) -> bool:
        ...
    def setAnchor(self, index: int, value: Rot3) -> None:
        ...
    def setAnchorWeight(self, value: float) -> None:
        ...
    def setCertifyOptimality(self, value: bool) -> None:
        ...
    def setGaugesWeight(self, value: float) -> None:
        ...
    def setKarcherWeight(self, value: float) -> None:
        ...
    def setOptimalityThreshold(self, value: float) -> None:
        ...
    def setUseHuber(self, value: bool) -> None:
        ...
class ShonanFactor3(NoiseModelFactor):
    @typing.overload
    def __init__(self, key1: int, key2: int, R12: Rot3, p: int) -> None:
        ...
    @typing.overload
    def __init__(self, key1: int, key2: int, R12: Rot3, p: int, model: noiseModel.Base) -> None:
        ...
    def evaluateError(self, Q1: SOn, Q2: SOn) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
class Similarity2:
    @staticmethod
    @typing.overload
    def Align(abPointPairs: list[tuple[numpy.ndarray[numpy.float64[2, 1]], numpy.ndarray[numpy.float64[2, 1]]]]) -> Similarity2:
        ...
    @staticmethod
    @typing.overload
    def Align(abPosePairs: list[tuple[Pose2, Pose2]]) -> Similarity2:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, s: float) -> None:
        ...
    @typing.overload
    def __init__(self, R: Rot2, t: numpy.ndarray[numpy.float64[2, 1]], s: float) -> None:
        ...
    @typing.overload
    def __init__(self, R: numpy.ndarray[numpy.float64[m, n]], t: numpy.ndarray[numpy.float64[m, 1]], s: float) -> None:
        ...
    @typing.overload
    def __init__(self, T: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def equals(self, sim: Similarity2, tol: float) -> bool:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def rotation(self) -> Rot2:
        ...
    def scale(self) -> float:
        ...
    @typing.overload
    def transformFrom(self, p: numpy.ndarray[numpy.float64[2, 1]]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def transformFrom(self, T: Pose2) -> Pose2:
        ...
    def translation(self) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
class Similarity3:
    @staticmethod
    @typing.overload
    def Align(abPointPairs: list[tuple[numpy.ndarray[numpy.float64[3, 1]], numpy.ndarray[numpy.float64[3, 1]]]]) -> Similarity3:
        ...
    @staticmethod
    @typing.overload
    def Align(abPosePairs: list[tuple[Pose3, Pose3]]) -> Similarity3:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, s: float) -> None:
        ...
    @typing.overload
    def __init__(self, R: Rot3, t: numpy.ndarray[numpy.float64[3, 1]], s: float) -> None:
        ...
    @typing.overload
    def __init__(self, R: numpy.ndarray[numpy.float64[m, n]], t: numpy.ndarray[numpy.float64[m, 1]], s: float) -> None:
        ...
    @typing.overload
    def __init__(self, T: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def equals(self, sim: Similarity3, tol: float) -> bool:
        ...
    def matrix(self) -> numpy.ndarray[numpy.float64[4, 4]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def rotation(self) -> Rot3:
        ...
    def scale(self) -> float:
        ...
    @typing.overload
    def transformFrom(self, p: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def transformFrom(self, T: Pose3) -> Pose3:
        ...
    def translation(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class SmartProjectionParams:
    def __init__(self) -> None:
        ...
    def setDegeneracyMode(self, degMode: DegeneracyMode) -> None:
        ...
    def setDynamicOutlierRejectionThreshold(self, dynOutRejectionThreshold: bool) -> None:
        ...
    def setEnableEPI(self, enableEPI: bool) -> None:
        ...
    def setLandmarkDistanceThreshold(self, landmarkDistanceThreshold: bool) -> None:
        ...
    def setLinearizationMode(self, linMode: LinearizationMode) -> None:
        ...
    def setRankTolerance(self, rankTol: float) -> None:
        ...
class SmartProjectionPose3Factor(NonlinearFactor):
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self, noise: noiseModel.Base, K: Cal3_S2) -> None:
        ...
    @typing.overload
    def __init__(self, noise: noiseModel.Base, K: Cal3_S2, body_P_sensor: Pose3) -> None:
        ...
    @typing.overload
    def __init__(self, noise: noiseModel.Base, K: Cal3_S2, params: SmartProjectionParams) -> None:
        ...
    @typing.overload
    def __init__(self, noise: noiseModel.Base, K: Cal3_S2, body_P_sensor: Pose3, params: SmartProjectionParams) -> None:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def add(self, measured_i: numpy.ndarray[numpy.float64[2, 1]], poseKey_i: int) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    @typing.overload
    def point(self) -> TriangulationResult:
        ...
    @typing.overload
    def point(self, values: Values) -> TriangulationResult:
        ...
    def serialize(self) -> str:
        ...
class StereoCamera:
    @staticmethod
    def Dim() -> int:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, pose: Pose3, K: Cal3_S2Stereo) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def backproject(self, p: StereoPoint2) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def backproject2(self, p: StereoPoint2, H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def baseline(self) -> float:
        ...
    def calibration(self) -> Cal3_S2Stereo:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def equals(self, camera: StereoCamera, tol: float) -> bool:
        ...
    def localCoordinates(self, T2: StereoCamera) -> numpy.ndarray[numpy.float64[6, 1]]:
        ...
    def pose(self) -> Pose3:
        ...
    def print(self, s: str = '') -> None:
        ...
    def project(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> StereoPoint2:
        ...
    def project2(self, point: numpy.ndarray[numpy.float64[3, 1]], H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> StereoPoint2:
        ...
    def retract(self, d: numpy.ndarray[numpy.float64[m, 1]]) -> StereoCamera:
        ...
    def serialize(self) -> str:
        ...
class StereoPoint2:
    @staticmethod
    def Expmap(v: numpy.ndarray[numpy.float64[m, 1]]) -> StereoPoint2:
        ...
    @staticmethod
    def Identity() -> StereoPoint2:
        ...
    @staticmethod
    def Logmap(p: StereoPoint2) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def __add__(self, arg0: StereoPoint2) -> StereoPoint2:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, uL: float, uR: float, v: float) -> None:
        ...
    def __neg__(self) -> StereoPoint2:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def __sub__(self, arg0: StereoPoint2) -> StereoPoint2:
        ...
    def between(self, p2: StereoPoint2) -> StereoPoint2:
        ...
    def compose(self, p2: StereoPoint2) -> StereoPoint2:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def equals(self, point: StereoPoint2, tol: float) -> bool:
        ...
    def inverse(self) -> StereoPoint2:
        ...
    def localCoordinates(self, p: StereoPoint2) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> StereoPoint2:
        ...
    def serialize(self) -> str:
        ...
    def uL(self) -> float:
        ...
    def uR(self) -> float:
        ...
    def v(self) -> float:
        ...
    def vector(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class SubgraphSolver:
    @typing.overload
    def __init__(self, A: GaussianFactorGraph, parameters: SubgraphSolverParameters, ordering: Ordering) -> None:
        ...
    @typing.overload
    def __init__(self, Ab1: GaussianFactorGraph, Ab2: GaussianFactorGraph, parameters: SubgraphSolverParameters, ordering: Ordering) -> None:
        ...
    def optimize(self) -> VectorValues:
        ...
class SubgraphSolverParameters(ConjugateGradientParameters):
    def __init__(self) -> None:
        ...
class Symbol:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, c: str, j: int) -> None:
        ...
    @typing.overload
    def __init__(self, key: int) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def chr(self) -> int:
        ...
    def equals(self, expected: Symbol, tol: float) -> bool:
        ...
    def index(self) -> int:
        ...
    def key(self) -> int:
        ...
    def print(self, s: str = '') -> None:
        ...
    def string(self) -> str:
        ...
class SymbolicBayesNet:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: SymbolicBayesNet) -> None:
        ...
    def __repr__(self, s: str = 'SymbolicBayesNet', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def at(self, idx: int) -> SymbolicConditional:
        ...
    def back(self) -> SymbolicConditional:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> str:
        ...
    def equals(self, other: SymbolicBayesNet, tol: float) -> bool:
        ...
    def front(self) -> SymbolicConditional:
        ...
    def print(self, s: str = 'SymbolicBayesNet', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def push_back(self, conditional: SymbolicConditional) -> None:
        ...
    @typing.overload
    def push_back(self, bayesNet: SymbolicBayesNet) -> None:
        ...
    @typing.overload
    def saveGraph(self, s: str) -> None:
        ...
    @typing.overload
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> None:
        ...
    def size(self) -> int:
        ...
class SymbolicBayesTree:
    def __getitem__(self, arg0: int) -> SymbolicBayesTreeClique:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: SymbolicBayesTree) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def clear(self) -> None:
        ...
    def deleteCachedShortcuts(self) -> None:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, other: SymbolicBayesTree, tol: float) -> bool:
        ...
    def joint(self, key1: int, key2: int) -> SymbolicFactorGraph:
        ...
    def jointBayesNet(self, key1: int, key2: int) -> SymbolicBayesNet:
        ...
    def marginalFactor(self, key: int) -> SymbolicConditional:
        ...
    def numCachedSeparatorMarginals(self) -> int:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def size(self) -> int:
        ...
class SymbolicBayesTreeClique:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, conditional: SymbolicConditional) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def conditional(self) -> SymbolicConditional:
        ...
    def deleteCachedShortcuts(self) -> None:
        ...
    def equals(self, other: SymbolicBayesTreeClique, tol: float) -> bool:
        ...
    def isRoot(self) -> bool:
        ...
    def numCachedSeparatorMarginals(self) -> int:
        ...
    def parent(self) -> SymbolicBayesTreeClique:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def treeSize(self) -> int:
        ...
class SymbolicCluster:
    factors: SymbolicFactorGraph
    orderedFrontalKeys: Ordering
    def __getitem__(self, arg0: int) -> SymbolicCluster:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def nrChildren(self) -> int:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class SymbolicConditional(SymbolicFactor):
    @staticmethod
    def FromKeys(keys: list[int], nrFrontals: int) -> SymbolicConditional:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: SymbolicConditional) -> None:
        ...
    @typing.overload
    def __init__(self, key: int) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, parent: int) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, parent1: int, parent2: int) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, parent1: int, parent2: int, parent3: int) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, other: SymbolicConditional, tol: float) -> bool:
        ...
    def firstFrontalKey(self) -> int:
        ...
    def nrFrontals(self) -> int:
        ...
    def nrParents(self) -> int:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class SymbolicEliminationTree:
    @typing.overload
    def __init__(self, factorGraph: SymbolicFactorGraph, structure: VariableIndex, order: Ordering) -> None:
        ...
    @typing.overload
    def __init__(self, factorGraph: SymbolicFactorGraph, order: Ordering) -> None:
        ...
    def __repr__(self, name: str = 'EliminationTree: ', formatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, other: SymbolicEliminationTree, tol: float = 1e-09) -> bool:
        ...
    def print(self, name: str = 'EliminationTree: ', formatter: typing.Callable[[int], str] = ...) -> None:
        ...
class SymbolicFactor(Factor):
    @staticmethod
    def FromKeys(js: list[int]) -> SymbolicFactor:
        ...
    @typing.overload
    def __init__(self, f: SymbolicFactor) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, j: int) -> None:
        ...
    @typing.overload
    def __init__(self, j1: int, j2: int) -> None:
        ...
    @typing.overload
    def __init__(self, j1: int, j2: int, j3: int) -> None:
        ...
    @typing.overload
    def __init__(self, j1: int, j2: int, j3: int, j4: int) -> None:
        ...
    @typing.overload
    def __init__(self, j1: int, j2: int, j3: int, j4: int, j5: int) -> None:
        ...
    @typing.overload
    def __init__(self, j1: int, j2: int, j3: int, j4: int, j5: int, j6: int) -> None:
        ...
    def __repr__(self, s: str = 'SymbolicFactor', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, other: SymbolicFactor, tol: float) -> bool:
        ...
    def print(self, s: str = 'SymbolicFactor', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
class SymbolicFactorGraph:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, bayesNet: ...) -> None:
        ...
    @typing.overload
    def __init__(self, bayesTree: ...) -> None:
        ...
    def __repr__(self, s: str = 'SymbolicFactorGraph', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def dot(self, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> str:
        ...
    @typing.overload
    def eliminateMultifrontal(self) -> ...:
        ...
    @typing.overload
    def eliminateMultifrontal(self, ordering: Ordering) -> ...:
        ...
    @typing.overload
    def eliminatePartialMultifrontal(self, ordering: Ordering) -> tuple[..., SymbolicFactorGraph]:
        ...
    @typing.overload
    def eliminatePartialMultifrontal(self, keys: list[int]) -> tuple[..., SymbolicFactorGraph]:
        ...
    @typing.overload
    def eliminatePartialSequential(self, ordering: Ordering) -> tuple[..., SymbolicFactorGraph]:
        ...
    @typing.overload
    def eliminatePartialSequential(self, keys: list[int]) -> tuple[..., SymbolicFactorGraph]:
        ...
    @typing.overload
    def eliminateSequential(self) -> ...:
        ...
    @typing.overload
    def eliminateSequential(self, ordering: Ordering) -> ...:
        ...
    def equals(self, rhs: SymbolicFactorGraph, tol: float) -> bool:
        ...
    def exists(self, idx: int) -> bool:
        ...
    def keys(self) -> ...:
        ...
    def marginal(self, key_vector: list[int]) -> SymbolicFactorGraph:
        ...
    @typing.overload
    def marginalMultifrontalBayesNet(self, ordering: Ordering) -> ...:
        ...
    @typing.overload
    def marginalMultifrontalBayesNet(self, key_vector: list[int]) -> ...:
        ...
    @typing.overload
    def marginalMultifrontalBayesNet(self, ordering: Ordering, marginalizedVariableOrdering: Ordering) -> ...:
        ...
    @typing.overload
    def marginalMultifrontalBayesNet(self, key_vector: list[int], marginalizedVariableOrdering: Ordering) -> ...:
        ...
    def print(self, s: str = 'SymbolicFactorGraph', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    @typing.overload
    def push_back(self, factor: SymbolicFactor) -> None:
        ...
    @typing.overload
    def push_back(self, graph: SymbolicFactorGraph) -> None:
        ...
    @typing.overload
    def push_back(self, bayesNet: ...) -> None:
        ...
    @typing.overload
    def push_back(self, bayesTree: ...) -> None:
        ...
    @typing.overload
    def push_factor(self, key: int) -> None:
        ...
    @typing.overload
    def push_factor(self, key1: int, key2: int) -> None:
        ...
    @typing.overload
    def push_factor(self, key1: int, key2: int, key3: int) -> None:
        ...
    @typing.overload
    def push_factor(self, key1: int, key2: int, key3: int, key4: int) -> None:
        ...
    def saveGraph(self, s: str, keyFormatter: typing.Callable[[int], str] = ..., writer: DotWriter = ...) -> None:
        ...
    def size(self) -> int:
        ...
class SymbolicJunctionTree:
    def __getitem__(self, arg0: int) -> SymbolicCluster:
        ...
    def __init__(self, eliminationTree: SymbolicEliminationTree) -> None:
        ...
    def __repr__(self, name: str = 'JunctionTree: ', formatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def nrRoots(self) -> int:
        ...
    def print(self, name: str = 'JunctionTree: ', formatter: typing.Callable[[int], str] = ...) -> None:
        ...
class TranslationRecovery:
    @typing.overload
    def __init__(self, lmParams: LevenbergMarquardtParams) -> None:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def addPrior(self, relativeTranslations: list[...], scale: float, betweenTranslations: list[..., 3, 1, 0, 3, ...], graph: NonlinearFactorGraph, priorNoiseModel: noiseModel.Base) -> None:
        ...
    @typing.overload
    def addPrior(self, relativeTranslations: list[...], scale: float, betweenTranslations: list[..., 3, 1, 0, 3, ...], graph: NonlinearFactorGraph) -> None:
        ...
    def buildGraph(self, relativeTranslations: list[...]) -> NonlinearFactorGraph:
        ...
    @typing.overload
    def run(self, relativeTranslations: list[...], scale: float, betweenTranslations: list[..., 3, 1, 0, 3, ...], initialValues: Values) -> Values:
        ...
    @typing.overload
    def run(self, relativeTranslations: list[...], scale: float, betweenTranslations: list[..., 3, 1, 0, 3, ...]) -> Values:
        ...
    @typing.overload
    def run(self, relativeTranslations: list[...], scale: float = 1.0) -> Values:
        ...
class TriangulationParameters:
    dynamicOutlierRejectionThreshold: float
    enableEPI: bool
    landmarkDistanceThreshold: float
    noiseModel: ...
    rankTolerance: float
    useLOST: bool
    def __init__(self, rankTolerance: float = 1.0, enableEPI: bool = False, landmarkDistanceThreshold: float = -1, dynamicOutlierRejectionThreshold: float = -1, useLOST: bool = False, noiseModel: ... = None) -> None:
        ...
class TriangulationResult:
    class Status:
        """
        Members:
        
          VALID
        
          DEGENERATE
        
          BEHIND_CAMERA
        
          OUTLIER
        
          FAR_POINT
        """
        BEHIND_CAMERA: typing.ClassVar[TriangulationResult.Status]  # value = <Status.BEHIND_CAMERA: 2>
        DEGENERATE: typing.ClassVar[TriangulationResult.Status]  # value = <Status.DEGENERATE: 1>
        FAR_POINT: typing.ClassVar[TriangulationResult.Status]  # value = <Status.FAR_POINT: 4>
        OUTLIER: typing.ClassVar[TriangulationResult.Status]  # value = <Status.OUTLIER: 3>
        VALID: typing.ClassVar[TriangulationResult.Status]  # value = <Status.VALID: 0>
        __members__: typing.ClassVar[dict[str, TriangulationResult.Status]]  # value = {'VALID': <Status.VALID: 0>, 'DEGENERATE': <Status.DEGENERATE: 1>, 'BEHIND_CAMERA': <Status.BEHIND_CAMERA: 2>, 'OUTLIER': <Status.OUTLIER: 3>, 'FAR_POINT': <Status.FAR_POINT: 4>}
        def __and__(self, other: typing.Any) -> typing.Any:
            ...
        def __eq__(self, other: typing.Any) -> bool:
            ...
        def __ge__(self, other: typing.Any) -> bool:
            ...
        def __getstate__(self) -> int:
            ...
        def __gt__(self, other: typing.Any) -> bool:
            ...
        def __hash__(self) -> int:
            ...
        def __index__(self) -> int:
            ...
        def __init__(self, value: int) -> None:
            ...
        def __int__(self) -> int:
            ...
        def __invert__(self) -> typing.Any:
            ...
        def __le__(self, other: typing.Any) -> bool:
            ...
        def __lt__(self, other: typing.Any) -> bool:
            ...
        def __ne__(self, other: typing.Any) -> bool:
            ...
        def __or__(self, other: typing.Any) -> typing.Any:
            ...
        def __rand__(self, other: typing.Any) -> typing.Any:
            ...
        def __repr__(self) -> str:
            ...
        def __ror__(self, other: typing.Any) -> typing.Any:
            ...
        def __rxor__(self, other: typing.Any) -> typing.Any:
            ...
        def __setstate__(self, state: int) -> None:
            ...
        def __str__(self) -> str:
            ...
        def __xor__(self, other: typing.Any) -> typing.Any:
            ...
        @property
        def name(self) -> str:
            ...
        @property
        def value(self) -> int:
            ...
    status: ...
    @staticmethod
    def BehindCamera() -> TriangulationResult:
        ...
    @staticmethod
    def Degenerate() -> TriangulationResult:
        ...
    @staticmethod
    def FarPoint() -> TriangulationResult:
        ...
    @staticmethod
    def Outlier() -> TriangulationResult:
        ...
    def __init__(self, p: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def behindCamera(self) -> bool:
        ...
    def degenerate(self) -> bool:
        ...
    def farPoint(self) -> bool:
        ...
    def get(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def outlier(self) -> bool:
        ...
    def valid(self) -> bool:
        ...
class Unit3:
    @staticmethod
    def Dim() -> int:
        ...
    @typing.overload
    def FromPoint3(self, point: numpy.ndarray[numpy.float64[3, 1]]) -> Unit3:
        ...
    @typing.overload
    def FromPoint3(self, point: numpy.ndarray[numpy.float64[3, 1]], H: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> Unit3:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, pose: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def __repr__(self, s: str = '') -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    @typing.overload
    def basis(self) -> numpy.ndarray[numpy.float64[3, 2]]:
        ...
    @typing.overload
    def basis(self, H: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 2]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    @typing.overload
    def dot(self, q: Unit3) -> float:
        ...
    @typing.overload
    def dot(self, q: Unit3, H1: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H2: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> float:
        ...
    @typing.overload
    def equals(self, pose: Unit3, tol: float) -> bool:
        ...
    @typing.overload
    def equals(self, expected: Unit3, tol: float) -> bool:
        ...
    @typing.overload
    def errorVector(self, q: Unit3) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def errorVector(self, q: Unit3, H_p: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous], H_q: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def localCoordinates(self, s: Unit3) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    @typing.overload
    def point3(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def point3(self, H: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def print(self, s: str = '') -> None:
        ...
    def retract(self, v: numpy.ndarray[numpy.float64[m, 1]]) -> Unit3:
        ...
    def serialize(self) -> str:
        ...
    def skew(self) -> numpy.ndarray[numpy.float64[3, 3]]:
        ...
    @typing.overload
    def unitVector(self) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    @typing.overload
    def unitVector(self, H: numpy.ndarray[numpy.float64[m, n], numpy.ndarray.flags.writeable, numpy.ndarray.flags.f_contiguous]) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
class Value:
    def __repr__(self, s: str = '') -> str:
        ...
    def dim(self) -> int:
        ...
    def print(self, s: str = '') -> None:
        ...
class Values:
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: Values) -> None:
        ...
    def __repr__(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def atCal3Bundler(self, j: int) -> Cal3Bundler:
        ...
    def atCal3DS2(self, j: int) -> Cal3DS2:
        ...
    def atCal3Fisheye(self, j: int) -> Cal3Fisheye:
        ...
    def atCal3Unified(self, j: int) -> Cal3Unified:
        ...
    def atCal3_S2(self, j: int) -> Cal3_S2:
        ...
    def atConstantBias(self, j: int) -> ...:
        ...
    def atDouble(self, j: int) -> float:
        ...
    def atEssentialMatrix(self, j: int) -> EssentialMatrix:
        ...
    def atMatrix(self, j: int) -> numpy.ndarray[numpy.float64[m, n]]:
        ...
    def atNavState(self, j: int) -> ...:
        ...
    def atPinholeCameraCal3Bundler(self, j: int) -> PinholeCameraCal3Bundler:
        ...
    def atPinholeCameraCal3Fisheye(self, j: int) -> PinholeCameraCal3Fisheye:
        ...
    def atPinholeCameraCal3Unified(self, j: int) -> PinholeCameraCal3Unified:
        ...
    def atPinholeCameraCal3_S2(self, j: int) -> PinholeCameraCal3_S2:
        ...
    def atPinholePoseCal3Bundler(self, j: int) -> PinholePoseCal3Bundler:
        ...
    def atPinholePoseCal3Fisheye(self, j: int) -> PinholePoseCal3Fisheye:
        ...
    def atPinholePoseCal3Unified(self, j: int) -> PinholePoseCal3Unified:
        ...
    def atPinholePoseCal3_S2(self, j: int) -> PinholePoseCal3_S2:
        ...
    def atPoint2(self, j: int) -> numpy.ndarray[numpy.float64[2, 1]]:
        ...
    def atPoint3(self, j: int) -> numpy.ndarray[numpy.float64[3, 1]]:
        ...
    def atPose2(self, j: int) -> Pose2:
        ...
    def atPose3(self, j: int) -> Pose3:
        ...
    def atRot2(self, j: int) -> Rot2:
        ...
    def atRot3(self, j: int) -> Rot3:
        ...
    def atSO3(self, j: int) -> SO3:
        ...
    def atSO4(self, j: int) -> SO4:
        ...
    def atSOn(self, j: int) -> SOn:
        ...
    def atUnit3(self, j: int) -> Unit3:
        ...
    def atVector(self, j: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def clear(self) -> None:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self) -> int:
        ...
    def empty(self) -> bool:
        ...
    def equals(self, other: Values, tol: float) -> bool:
        ...
    def erase(self, j: int) -> None:
        ...
    def exists(self, j: int) -> bool:
        ...
    @typing.overload
    def insert(self, values: Values) -> None:
        ...
    @typing.overload
    def insert(self, j: int, vector: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def insert(self, j: int, matrix: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def insert(self, j: int, point2: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def insert(self, j: int, point3: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def insert(self, j: int, rot2: Rot2) -> None:
        ...
    @typing.overload
    def insert(self, j: int, pose2: Pose2) -> None:
        ...
    @typing.overload
    def insert(self, j: int, R: SO3) -> None:
        ...
    @typing.overload
    def insert(self, j: int, Q: SO4) -> None:
        ...
    @typing.overload
    def insert(self, j: int, P: SOn) -> None:
        ...
    @typing.overload
    def insert(self, j: int, rot3: Rot3) -> None:
        ...
    @typing.overload
    def insert(self, j: int, pose3: Pose3) -> None:
        ...
    @typing.overload
    def insert(self, j: int, unit3: Unit3) -> None:
        ...
    @typing.overload
    def insert(self, j: int, cal3_s2: Cal3_S2) -> None:
        ...
    @typing.overload
    def insert(self, j: int, cal3ds2: Cal3DS2) -> None:
        ...
    @typing.overload
    def insert(self, j: int, cal3bundler: Cal3Bundler) -> None:
        ...
    @typing.overload
    def insert(self, j: int, cal3fisheye: Cal3Fisheye) -> None:
        ...
    @typing.overload
    def insert(self, j: int, cal3unified: Cal3Unified) -> None:
        ...
    @typing.overload
    def insert(self, j: int, essential_matrix: EssentialMatrix) -> None:
        ...
    @typing.overload
    def insert(self, j: int, camera: PinholeCameraCal3_S2) -> None:
        ...
    @typing.overload
    def insert(self, j: int, camera: PinholeCameraCal3Bundler) -> None:
        ...
    @typing.overload
    def insert(self, j: int, camera: PinholeCameraCal3Fisheye) -> None:
        ...
    @typing.overload
    def insert(self, j: int, camera: PinholeCameraCal3Unified) -> None:
        ...
    @typing.overload
    def insert(self, j: int, camera: PinholePoseCal3_S2) -> None:
        ...
    @typing.overload
    def insert(self, j: int, camera: PinholePoseCal3Bundler) -> None:
        ...
    @typing.overload
    def insert(self, j: int, camera: PinholePoseCal3Fisheye) -> None:
        ...
    @typing.overload
    def insert(self, j: int, camera: PinholePoseCal3Unified) -> None:
        ...
    @typing.overload
    def insert(self, j: int, constant_bias: ...) -> None:
        ...
    @typing.overload
    def insert(self, j: int, nav_state: ...) -> None:
        ...
    @typing.overload
    def insert(self, j: int, c: float) -> None:
        ...
    def insertPoint2(self, j: int, val: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    def insertPoint3(self, j: int, val: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def insert_P(self, j: int, P: SOn) -> None:
        ...
    def insert_Q(self, j: int, Q: SO4) -> None:
        ...
    def insert_R(self, j: int, R: SO3) -> None:
        ...
    def insert_c(self, j: int, c: float) -> None:
        ...
    def insert_cal3_s2(self, j: int, cal3_s2: Cal3_S2) -> None:
        ...
    def insert_cal3bundler(self, j: int, cal3bundler: Cal3Bundler) -> None:
        ...
    def insert_cal3ds2(self, j: int, cal3ds2: Cal3DS2) -> None:
        ...
    def insert_cal3fisheye(self, j: int, cal3fisheye: Cal3Fisheye) -> None:
        ...
    def insert_cal3unified(self, j: int, cal3unified: Cal3Unified) -> None:
        ...
    @typing.overload
    def insert_camera(self, j: int, camera: PinholeCameraCal3_S2) -> None:
        ...
    @typing.overload
    def insert_camera(self, j: int, camera: PinholeCameraCal3Bundler) -> None:
        ...
    @typing.overload
    def insert_camera(self, j: int, camera: PinholeCameraCal3Fisheye) -> None:
        ...
    @typing.overload
    def insert_camera(self, j: int, camera: PinholeCameraCal3Unified) -> None:
        ...
    @typing.overload
    def insert_camera(self, j: int, camera: PinholePoseCal3_S2) -> None:
        ...
    @typing.overload
    def insert_camera(self, j: int, camera: PinholePoseCal3Bundler) -> None:
        ...
    @typing.overload
    def insert_camera(self, j: int, camera: PinholePoseCal3Fisheye) -> None:
        ...
    @typing.overload
    def insert_camera(self, j: int, camera: PinholePoseCal3Unified) -> None:
        ...
    def insert_constant_bias(self, j: int, constant_bias: ...) -> None:
        ...
    def insert_essential_matrix(self, j: int, essential_matrix: EssentialMatrix) -> None:
        ...
    def insert_matrix(self, j: int, matrix: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    def insert_nav_state(self, j: int, nav_state: ...) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, values: Values) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, vector: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, matrix: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, point2: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, point3: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, rot2: Rot2) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, pose2: Pose2) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, R: SO3) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, Q: SO4) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, P: SOn) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, rot3: Rot3) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, pose3: Pose3) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, unit3: Unit3) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, cal3_s2: Cal3_S2) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, cal3ds2: Cal3DS2) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, cal3bundler: Cal3Bundler) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, cal3fisheye: Cal3Fisheye) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, cal3unified: Cal3Unified) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, essential_matrix: EssentialMatrix) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, camera: PinholeCameraCal3_S2) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, camera: PinholeCameraCal3Bundler) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, camera: PinholeCameraCal3Fisheye) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, camera: PinholeCameraCal3Unified) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, camera: PinholePoseCal3_S2) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, camera: PinholePoseCal3Bundler) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, camera: PinholePoseCal3Fisheye) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, camera: PinholePoseCal3Unified) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, constant_bias: ...) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, nav_state: ...) -> None:
        ...
    @typing.overload
    def insert_or_assign(self, j: int, c: float) -> None:
        ...
    def insert_point2(self, j: int, point2: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    def insert_point3(self, j: int, point3: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    def insert_pose2(self, j: int, pose2: Pose2) -> None:
        ...
    def insert_pose3(self, j: int, pose3: Pose3) -> None:
        ...
    def insert_rot2(self, j: int, rot2: Rot2) -> None:
        ...
    def insert_rot3(self, j: int, rot3: Rot3) -> None:
        ...
    def insert_unit3(self, j: int, unit3: Unit3) -> None:
        ...
    def insert_vector(self, j: int, vector: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    def keys(self) -> list[int]:
        ...
    def localCoordinates(self, cp: Values) -> VectorValues:
        ...
    def print(self, s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def retract(self, delta: VectorValues) -> Values:
        ...
    def serialize(self) -> str:
        ...
    def size(self) -> int:
        ...
    def swap(self, values: Values) -> None:
        ...
    @typing.overload
    def update(self, values: Values) -> None:
        ...
    @typing.overload
    def update(self, j: int, vector: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def update(self, j: int, matrix: numpy.ndarray[numpy.float64[m, n]]) -> None:
        ...
    @typing.overload
    def update(self, j: int, point2: numpy.ndarray[numpy.float64[2, 1]]) -> None:
        ...
    @typing.overload
    def update(self, j: int, point3: numpy.ndarray[numpy.float64[3, 1]]) -> None:
        ...
    @typing.overload
    def update(self, j: int, rot2: Rot2) -> None:
        ...
    @typing.overload
    def update(self, j: int, pose2: Pose2) -> None:
        ...
    @typing.overload
    def update(self, j: int, R: SO3) -> None:
        ...
    @typing.overload
    def update(self, j: int, Q: SO4) -> None:
        ...
    @typing.overload
    def update(self, j: int, P: SOn) -> None:
        ...
    @typing.overload
    def update(self, j: int, rot3: Rot3) -> None:
        ...
    @typing.overload
    def update(self, j: int, pose3: Pose3) -> None:
        ...
    @typing.overload
    def update(self, j: int, unit3: Unit3) -> None:
        ...
    @typing.overload
    def update(self, j: int, cal3_s2: Cal3_S2) -> None:
        ...
    @typing.overload
    def update(self, j: int, cal3ds2: Cal3DS2) -> None:
        ...
    @typing.overload
    def update(self, j: int, cal3bundler: Cal3Bundler) -> None:
        ...
    @typing.overload
    def update(self, j: int, cal3fisheye: Cal3Fisheye) -> None:
        ...
    @typing.overload
    def update(self, j: int, cal3unified: Cal3Unified) -> None:
        ...
    @typing.overload
    def update(self, j: int, essential_matrix: EssentialMatrix) -> None:
        ...
    @typing.overload
    def update(self, j: int, camera: PinholeCameraCal3_S2) -> None:
        ...
    @typing.overload
    def update(self, j: int, camera: PinholeCameraCal3Bundler) -> None:
        ...
    @typing.overload
    def update(self, j: int, camera: PinholeCameraCal3Fisheye) -> None:
        ...
    @typing.overload
    def update(self, j: int, camera: PinholeCameraCal3Unified) -> None:
        ...
    @typing.overload
    def update(self, j: int, camera: PinholePoseCal3_S2) -> None:
        ...
    @typing.overload
    def update(self, j: int, camera: PinholePoseCal3Bundler) -> None:
        ...
    @typing.overload
    def update(self, j: int, camera: PinholePoseCal3Fisheye) -> None:
        ...
    @typing.overload
    def update(self, j: int, camera: PinholePoseCal3Unified) -> None:
        ...
    @typing.overload
    def update(self, j: int, constant_bias: ...) -> None:
        ...
    @typing.overload
    def update(self, j: int, nav_state: ...) -> None:
        ...
    @typing.overload
    def update(self, j: int, c: float) -> None:
        ...
    def zeroVectors(self) -> VectorValues:
        ...
class VariableIndex:
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, factorGraph: ...) -> None:
        ...
    @typing.overload
    def __init__(self, factorGraph: ...) -> None:
        ...
    @typing.overload
    def __init__(self, factorGraph: ...) -> None:
        ...
    @typing.overload
    def __init__(self, other: VariableIndex) -> None:
        ...
    def __repr__(self, s: str = 'VariableIndex: ', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def equals(self, other: VariableIndex, tol: float) -> bool:
        ...
    def nEntries(self) -> int:
        ...
    def nFactors(self) -> int:
        ...
    def print(self, s: str = 'VariableIndex: ', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def size(self) -> int:
        ...
class VectorComponentFactorChebyshev1Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, M: int, N: int, i: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, M: int, N: int, i: int, x: float, a: float, b: float) -> None:
        ...
class VectorComponentFactorChebyshev2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, M: int, N: int, i: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, M: int, N: int, i: int, x: float, a: float, b: float) -> None:
        ...
class VectorComponentFactorChebyshev2Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, M: int, N: int, i: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, M: int, N: int, i: int, x: float, a: float, b: float) -> None:
        ...
class VectorComponentFactorFourierBasis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, M: int, N: int, i: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: float, model: noiseModel.Base, M: int, N: int, i: int, x: float, a: float, b: float) -> None:
        ...
class VectorDerivativeFactorChebyshev1Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float, a: float, b: float) -> None:
        ...
class VectorDerivativeFactorChebyshev2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float, a: float, b: float) -> None:
        ...
class VectorDerivativeFactorChebyshev2Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float, a: float, b: float) -> None:
        ...
class VectorDerivativeFactorFourierBasis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float, a: float, b: float) -> None:
        ...
class VectorEvaluationFactorChebyshev1Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float, a: float, b: float) -> None:
        ...
class VectorEvaluationFactorChebyshev2(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float, a: float, b: float) -> None:
        ...
class VectorEvaluationFactorChebyshev2Basis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float, a: float, b: float) -> None:
        ...
class VectorEvaluationFactorFourierBasis(NoiseModelFactor):
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float) -> None:
        ...
    @typing.overload
    def __init__(self, key: int, z: numpy.ndarray[numpy.float64[m, 1]], model: noiseModel.Base, M: int, N: int, x: float, a: float, b: float) -> None:
        ...
class VectorValues:
    @staticmethod
    def Zero(model: VectorValues) -> VectorValues:
        ...
    def __getstate__(self) -> tuple:
        ...
    @typing.overload
    def __init__(self) -> None:
        ...
    @typing.overload
    def __init__(self, other: VectorValues) -> None:
        ...
    @typing.overload
    def __init__(self, first: VectorValues, second: VectorValues) -> None:
        ...
    def __repr__(self, s: str = 'VectorValues', keyFormatter: typing.Callable[[int], str] = ...) -> str:
        ...
    def __setstate__(self, arg0: tuple) -> None:
        ...
    def _repr_html_(self) -> str:
        ...
    def add(self, c: VectorValues) -> VectorValues:
        ...
    def addInPlace(self, c: VectorValues) -> None:
        ...
    def at(self, j: int) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    def deserialize(self, serialized: str) -> None:
        ...
    def dim(self, j: int) -> int:
        ...
    def dot(self, V: VectorValues) -> float:
        ...
    def equals(self, expected: VectorValues, tol: float) -> bool:
        ...
    def exists(self, j: int) -> bool:
        ...
    def hasSameStructure(self, other: VectorValues) -> bool:
        ...
    @typing.overload
    def insert(self, j: int, value: numpy.ndarray[numpy.float64[m, 1]]) -> None:
        ...
    @typing.overload
    def insert(self, values: VectorValues) -> None:
        ...
    def norm(self) -> float:
        ...
    def print(self, s: str = 'VectorValues', keyFormatter: typing.Callable[[int], str] = ...) -> None:
        ...
    def scale(self, a: float) -> VectorValues:
        ...
    def scaleInPlace(self, a: float) -> None:
        ...
    def serialize(self) -> str:
        ...
    def setZero(self) -> None:
        ...
    def size(self) -> int:
        ...
    def squaredNorm(self) -> float:
        ...
    def subtract(self, c: VectorValues) -> VectorValues:
        ...
    def update(self, values: VectorValues) -> None:
        ...
    @typing.overload
    def vector(self) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
    @typing.overload
    def vector(self, keys: list[int]) -> numpy.ndarray[numpy.float64[m, 1]]:
        ...
def ConvertNoiseModel(model: noiseModel.Base, d: int) -> noiseModel.Base:
    ...
def EliminateDiscrete(factors: DiscreteFactorGraph, frontalKeys: Ordering) -> tuple[DiscreteConditional, DecisionTreeFactor]:
    ...
def EliminateForMPE(factors: DiscreteFactorGraph, frontalKeys: Ordering) -> tuple[DiscreteConditional, DecisionTreeFactor]:
    ...
def FindKarcherMean(rotations: list[Rot3]) -> Rot3:
    ...
def IndexPairSetAsArray(set: set[IndexPair]) -> list[IndexPair]:
    ...
def PrintKeyList(keys: ..., s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
    ...
def PrintKeySet(keys: ..., s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
    ...
def PrintKeyVector(keys: list[int], s: str = '', keyFormatter: typing.Callable[[int], str] = ...) -> None:
    ...
def cartesianProduct(keys: DiscreteKeys) -> list[...]:
    ...
@typing.overload
def checkConvergence(relativeErrorTreshold: float, absoluteErrorTreshold: float, errorThreshold: float, currentError: float, newError: float) -> bool:
    ...
@typing.overload
def checkConvergence(params: NonlinearOptimizerParams, currentError: float, newError: float) -> bool:
    ...
@typing.overload
def html(values: ..., keyFormatter: typing.Callable[[int], str] = ...) -> str:
    ...
@typing.overload
def html(values: ..., keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
    ...
def initialCamerasAndPointsEstimate(db: SfmData) -> Values:
    ...
def initialCamerasEstimate(db: SfmData) -> Values:
    ...
def isDebugVersion() -> bool:
    ...
def linear_independent(A: numpy.ndarray[numpy.float64[m, n]], B: numpy.ndarray[numpy.float64[m, n]], tol: float) -> bool:
    ...
def load2D(filename: str, model: noiseModel.Diagonal = None, maxIndex: int = 0, addNoise: bool = False, smart: bool = True, noiseFormat: NoiseFormat = NoiseFormat.NoiseFormatAUTO, kernelFunctionType: KernelFunctionType = KernelFunctionType.KernelFunctionTypeNONE) -> tuple[NonlinearFactorGraph, Values]:
    ...
def load3D(filename: str) -> tuple[NonlinearFactorGraph, Values]:
    ...
@typing.overload
def markdown(values: ..., keyFormatter: typing.Callable[[int], str] = ...) -> str:
    ...
@typing.overload
def markdown(values: ..., keyFormatter: typing.Callable[[int], str], names: dict[int, list[str]]) -> str:
    ...
def mrsymbol(c: int, label: int, j: int) -> int:
    ...
def mrsymbolChr(key: int) -> int:
    ...
def mrsymbolIndex(key: int) -> int:
    ...
def mrsymbolLabel(key: int) -> int:
    ...
def parse2DFactors(filename: str) -> list[BetweenFactorPose2]:
    ...
def parse3DFactors(filename: str) -> list[BetweenFactorPose3]:
    ...
def readBal(filename: str) -> SfmData:
    ...
def readG2o(filename: str, is3D: bool = False, kernelFunctionType: KernelFunctionType = KernelFunctionType.KernelFunctionTypeNONE) -> tuple[NonlinearFactorGraph, Values]:
    ...
def save2D(graph: NonlinearFactorGraph, config: Values, model: noiseModel.Diagonal, filename: str) -> None:
    ...
def symbol(chr: str, index: int) -> int:
    ...
def symbolChr(key: int) -> int:
    ...
def symbolIndex(key: int) -> int:
    ...
@typing.overload
def triangulateNonlinear(poses: list[Pose3], sharedCal: Cal3_S2, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateNonlinear(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateNonlinear(poses: list[Pose3], sharedCal: Cal3DS2, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateNonlinear(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateNonlinear(poses: list[Pose3], sharedCal: Cal3Bundler, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateNonlinear(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateNonlinear(poses: list[Pose3], sharedCal: Cal3Fisheye, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateNonlinear(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateNonlinear(poses: list[Pose3], sharedCal: Cal3Unified, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateNonlinear(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], initialEstimate: numpy.ndarray[numpy.float64[3, 1]]) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(poses: list[Pose3], sharedCal: Cal3_S2, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None, useLOST: bool = False) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(poses: list[Pose3], sharedCal: Cal3DS2, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None, useLOST: bool = False) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(poses: list[Pose3], sharedCal: Cal3Bundler, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None, useLOST: bool = False) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(poses: list[Pose3], sharedCal: Cal3Fisheye, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None, useLOST: bool = False) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(poses: list[Pose3], sharedCal: Cal3Unified, measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulatePoint3(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], rank_tol: float, optimize: bool, model: ... = None, useLOST: bool = False) -> numpy.ndarray[numpy.float64[3, 1]]:
    ...
@typing.overload
def triangulateSafe(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], params: TriangulationParameters) -> TriangulationResult:
    ...
@typing.overload
def triangulateSafe(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], params: TriangulationParameters) -> TriangulationResult:
    ...
@typing.overload
def triangulateSafe(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], params: TriangulationParameters) -> TriangulationResult:
    ...
@typing.overload
def triangulateSafe(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], params: TriangulationParameters) -> TriangulationResult:
    ...
@typing.overload
def triangulateSafe(cameras: ..., measurements: list[numpy.ndarray[numpy.float64[2, 1]]], params: TriangulationParameters) -> TriangulationResult:
    ...
def writeBAL(filename: str, data: SfmData) -> bool:
    ...
def writeG2o(graph: NonlinearFactorGraph, estimate: Values, filename: str) -> None:
    ...
